// Code generated by ent, DO NOT EDIT.

package entv1

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/busyster996/dagflow/internal/entv1/param"
	"github.com/busyster996/dagflow/internal/entv1/predicate"
	"github.com/busyster996/dagflow/internal/entv1/schema"
	"github.com/busyster996/dagflow/internal/entv1/step"
	"github.com/busyster996/dagflow/internal/entv1/stepdepend"
	"github.com/busyster996/dagflow/internal/entv1/stepparam"
	"github.com/busyster996/dagflow/internal/entv1/task"
	"github.com/busyster996/dagflow/internal/entv1/taskparam"
	"github.com/busyster996/dagflow/internal/entv1/taskstep"
	"github.com/busyster996/dagflow/internal/entv1/taskstepoutput"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeParam          = "Param"
	TypeStep           = "Step"
	TypeStepDepend     = "StepDepend"
	TypeStepParam      = "StepParam"
	TypeTask           = "Task"
	TypeTaskParam      = "TaskParam"
	TypeTaskStep       = "TaskStep"
	TypeTaskStepOutput = "TaskStepOutput"
)

// ParamMutation represents an operation that mutates the Param nodes in the graph.
type ParamMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint64
	created_at         *time.Time
	updated_at         *time.Time
	created_by         *string
	updated_by         *string
	name               *string
	value              *string
	clearedFields      map[string]struct{}
	tasks              map[uint64]struct{}
	removedtasks       map[uint64]struct{}
	clearedtasks       bool
	steps              map[uint64]struct{}
	removedsteps       map[uint64]struct{}
	clearedsteps       bool
	task_params        map[uint64]struct{}
	removedtask_params map[uint64]struct{}
	clearedtask_params bool
	step_params        map[uint64]struct{}
	removedstep_params map[uint64]struct{}
	clearedstep_params bool
	done               bool
	oldValue           func(context.Context) (*Param, error)
	predicates         []predicate.Param
}

var _ ent.Mutation = (*ParamMutation)(nil)

// paramOption allows management of the mutation configuration using functional options.
type paramOption func(*ParamMutation)

// newParamMutation creates new mutation for the Param entity.
func newParamMutation(c config, op Op, opts ...paramOption) *ParamMutation {
	m := &ParamMutation{
		config:        c,
		op:            op,
		typ:           TypeParam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withParamID sets the ID field of the mutation.
func withParamID(id uint64) paramOption {
	return func(m *ParamMutation) {
		var (
			err   error
			once  sync.Once
			value *Param
		)
		m.oldValue = func(ctx context.Context) (*Param, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Param.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withParam sets the old Param of the mutation.
func withParam(node *Param) paramOption {
	return func(m *ParamMutation) {
		m.oldValue = func(context.Context) (*Param, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ParamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ParamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entv1: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Param entities.
func (m *ParamMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ParamMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ParamMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Param.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ParamMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ParamMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Param entity.
// If the Param object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParamMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ParamMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[param.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ParamMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[param.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ParamMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, param.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ParamMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ParamMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Param entity.
// If the Param object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParamMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ParamMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[param.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ParamMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[param.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ParamMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, param.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *ParamMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ParamMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Param entity.
// If the Param object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParamMutation) OldCreatedBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ParamMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[param.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ParamMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[param.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ParamMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, param.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ParamMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ParamMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Param entity.
// If the Param object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParamMutation) OldUpdatedBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ParamMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[param.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ParamMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[param.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ParamMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, param.FieldUpdatedBy)
}

// SetName sets the "name" field.
func (m *ParamMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ParamMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Param entity.
// If the Param object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParamMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ParamMutation) ResetName() {
	m.name = nil
}

// SetValue sets the "value" field.
func (m *ParamMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *ParamMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Param entity.
// If the Param object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParamMutation) OldValue(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ClearValue clears the value of the "value" field.
func (m *ParamMutation) ClearValue() {
	m.value = nil
	m.clearedFields[param.FieldValue] = struct{}{}
}

// ValueCleared returns if the "value" field was cleared in this mutation.
func (m *ParamMutation) ValueCleared() bool {
	_, ok := m.clearedFields[param.FieldValue]
	return ok
}

// ResetValue resets all changes to the "value" field.
func (m *ParamMutation) ResetValue() {
	m.value = nil
	delete(m.clearedFields, param.FieldValue)
}

// AddTaskIDs adds the "tasks" edge to the Task entity by ids.
func (m *ParamMutation) AddTaskIDs(ids ...uint64) {
	if m.tasks == nil {
		m.tasks = make(map[uint64]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the Task entity.
func (m *ParamMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the Task entity was cleared.
func (m *ParamMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the Task entity by IDs.
func (m *ParamMutation) RemoveTaskIDs(ids ...uint64) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the Task entity.
func (m *ParamMutation) RemovedTasksIDs() (ids []uint64) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *ParamMutation) TasksIDs() (ids []uint64) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *ParamMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// AddStepIDs adds the "steps" edge to the Step entity by ids.
func (m *ParamMutation) AddStepIDs(ids ...uint64) {
	if m.steps == nil {
		m.steps = make(map[uint64]struct{})
	}
	for i := range ids {
		m.steps[ids[i]] = struct{}{}
	}
}

// ClearSteps clears the "steps" edge to the Step entity.
func (m *ParamMutation) ClearSteps() {
	m.clearedsteps = true
}

// StepsCleared reports if the "steps" edge to the Step entity was cleared.
func (m *ParamMutation) StepsCleared() bool {
	return m.clearedsteps
}

// RemoveStepIDs removes the "steps" edge to the Step entity by IDs.
func (m *ParamMutation) RemoveStepIDs(ids ...uint64) {
	if m.removedsteps == nil {
		m.removedsteps = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.steps, ids[i])
		m.removedsteps[ids[i]] = struct{}{}
	}
}

// RemovedSteps returns the removed IDs of the "steps" edge to the Step entity.
func (m *ParamMutation) RemovedStepsIDs() (ids []uint64) {
	for id := range m.removedsteps {
		ids = append(ids, id)
	}
	return
}

// StepsIDs returns the "steps" edge IDs in the mutation.
func (m *ParamMutation) StepsIDs() (ids []uint64) {
	for id := range m.steps {
		ids = append(ids, id)
	}
	return
}

// ResetSteps resets all changes to the "steps" edge.
func (m *ParamMutation) ResetSteps() {
	m.steps = nil
	m.clearedsteps = false
	m.removedsteps = nil
}

// AddTaskParamIDs adds the "task_params" edge to the TaskParam entity by ids.
func (m *ParamMutation) AddTaskParamIDs(ids ...uint64) {
	if m.task_params == nil {
		m.task_params = make(map[uint64]struct{})
	}
	for i := range ids {
		m.task_params[ids[i]] = struct{}{}
	}
}

// ClearTaskParams clears the "task_params" edge to the TaskParam entity.
func (m *ParamMutation) ClearTaskParams() {
	m.clearedtask_params = true
}

// TaskParamsCleared reports if the "task_params" edge to the TaskParam entity was cleared.
func (m *ParamMutation) TaskParamsCleared() bool {
	return m.clearedtask_params
}

// RemoveTaskParamIDs removes the "task_params" edge to the TaskParam entity by IDs.
func (m *ParamMutation) RemoveTaskParamIDs(ids ...uint64) {
	if m.removedtask_params == nil {
		m.removedtask_params = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.task_params, ids[i])
		m.removedtask_params[ids[i]] = struct{}{}
	}
}

// RemovedTaskParams returns the removed IDs of the "task_params" edge to the TaskParam entity.
func (m *ParamMutation) RemovedTaskParamsIDs() (ids []uint64) {
	for id := range m.removedtask_params {
		ids = append(ids, id)
	}
	return
}

// TaskParamsIDs returns the "task_params" edge IDs in the mutation.
func (m *ParamMutation) TaskParamsIDs() (ids []uint64) {
	for id := range m.task_params {
		ids = append(ids, id)
	}
	return
}

// ResetTaskParams resets all changes to the "task_params" edge.
func (m *ParamMutation) ResetTaskParams() {
	m.task_params = nil
	m.clearedtask_params = false
	m.removedtask_params = nil
}

// AddStepParamIDs adds the "step_params" edge to the StepParam entity by ids.
func (m *ParamMutation) AddStepParamIDs(ids ...uint64) {
	if m.step_params == nil {
		m.step_params = make(map[uint64]struct{})
	}
	for i := range ids {
		m.step_params[ids[i]] = struct{}{}
	}
}

// ClearStepParams clears the "step_params" edge to the StepParam entity.
func (m *ParamMutation) ClearStepParams() {
	m.clearedstep_params = true
}

// StepParamsCleared reports if the "step_params" edge to the StepParam entity was cleared.
func (m *ParamMutation) StepParamsCleared() bool {
	return m.clearedstep_params
}

// RemoveStepParamIDs removes the "step_params" edge to the StepParam entity by IDs.
func (m *ParamMutation) RemoveStepParamIDs(ids ...uint64) {
	if m.removedstep_params == nil {
		m.removedstep_params = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.step_params, ids[i])
		m.removedstep_params[ids[i]] = struct{}{}
	}
}

// RemovedStepParams returns the removed IDs of the "step_params" edge to the StepParam entity.
func (m *ParamMutation) RemovedStepParamsIDs() (ids []uint64) {
	for id := range m.removedstep_params {
		ids = append(ids, id)
	}
	return
}

// StepParamsIDs returns the "step_params" edge IDs in the mutation.
func (m *ParamMutation) StepParamsIDs() (ids []uint64) {
	for id := range m.step_params {
		ids = append(ids, id)
	}
	return
}

// ResetStepParams resets all changes to the "step_params" edge.
func (m *ParamMutation) ResetStepParams() {
	m.step_params = nil
	m.clearedstep_params = false
	m.removedstep_params = nil
}

// Where appends a list predicates to the ParamMutation builder.
func (m *ParamMutation) Where(ps ...predicate.Param) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ParamMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ParamMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Param, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ParamMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ParamMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Param).
func (m *ParamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ParamMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, param.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, param.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, param.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, param.FieldUpdatedBy)
	}
	if m.name != nil {
		fields = append(fields, param.FieldName)
	}
	if m.value != nil {
		fields = append(fields, param.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ParamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case param.FieldCreatedAt:
		return m.CreatedAt()
	case param.FieldUpdatedAt:
		return m.UpdatedAt()
	case param.FieldCreatedBy:
		return m.CreatedBy()
	case param.FieldUpdatedBy:
		return m.UpdatedBy()
	case param.FieldName:
		return m.Name()
	case param.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ParamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case param.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case param.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case param.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case param.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case param.FieldName:
		return m.OldName(ctx)
	case param.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown Param field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ParamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case param.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case param.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case param.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case param.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case param.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case param.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown Param field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ParamMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ParamMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ParamMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Param numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ParamMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(param.FieldCreatedAt) {
		fields = append(fields, param.FieldCreatedAt)
	}
	if m.FieldCleared(param.FieldUpdatedAt) {
		fields = append(fields, param.FieldUpdatedAt)
	}
	if m.FieldCleared(param.FieldCreatedBy) {
		fields = append(fields, param.FieldCreatedBy)
	}
	if m.FieldCleared(param.FieldUpdatedBy) {
		fields = append(fields, param.FieldUpdatedBy)
	}
	if m.FieldCleared(param.FieldValue) {
		fields = append(fields, param.FieldValue)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ParamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ParamMutation) ClearField(name string) error {
	switch name {
	case param.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case param.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case param.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case param.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case param.FieldValue:
		m.ClearValue()
		return nil
	}
	return fmt.Errorf("unknown Param nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ParamMutation) ResetField(name string) error {
	switch name {
	case param.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case param.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case param.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case param.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case param.FieldName:
		m.ResetName()
		return nil
	case param.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown Param field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ParamMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tasks != nil {
		edges = append(edges, param.EdgeTasks)
	}
	if m.steps != nil {
		edges = append(edges, param.EdgeSteps)
	}
	if m.task_params != nil {
		edges = append(edges, param.EdgeTaskParams)
	}
	if m.step_params != nil {
		edges = append(edges, param.EdgeStepParams)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ParamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case param.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	case param.EdgeSteps:
		ids := make([]ent.Value, 0, len(m.steps))
		for id := range m.steps {
			ids = append(ids, id)
		}
		return ids
	case param.EdgeTaskParams:
		ids := make([]ent.Value, 0, len(m.task_params))
		for id := range m.task_params {
			ids = append(ids, id)
		}
		return ids
	case param.EdgeStepParams:
		ids := make([]ent.Value, 0, len(m.step_params))
		for id := range m.step_params {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ParamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedtasks != nil {
		edges = append(edges, param.EdgeTasks)
	}
	if m.removedsteps != nil {
		edges = append(edges, param.EdgeSteps)
	}
	if m.removedtask_params != nil {
		edges = append(edges, param.EdgeTaskParams)
	}
	if m.removedstep_params != nil {
		edges = append(edges, param.EdgeStepParams)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ParamMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case param.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	case param.EdgeSteps:
		ids := make([]ent.Value, 0, len(m.removedsteps))
		for id := range m.removedsteps {
			ids = append(ids, id)
		}
		return ids
	case param.EdgeTaskParams:
		ids := make([]ent.Value, 0, len(m.removedtask_params))
		for id := range m.removedtask_params {
			ids = append(ids, id)
		}
		return ids
	case param.EdgeStepParams:
		ids := make([]ent.Value, 0, len(m.removedstep_params))
		for id := range m.removedstep_params {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ParamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtasks {
		edges = append(edges, param.EdgeTasks)
	}
	if m.clearedsteps {
		edges = append(edges, param.EdgeSteps)
	}
	if m.clearedtask_params {
		edges = append(edges, param.EdgeTaskParams)
	}
	if m.clearedstep_params {
		edges = append(edges, param.EdgeStepParams)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ParamMutation) EdgeCleared(name string) bool {
	switch name {
	case param.EdgeTasks:
		return m.clearedtasks
	case param.EdgeSteps:
		return m.clearedsteps
	case param.EdgeTaskParams:
		return m.clearedtask_params
	case param.EdgeStepParams:
		return m.clearedstep_params
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ParamMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Param unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ParamMutation) ResetEdge(name string) error {
	switch name {
	case param.EdgeTasks:
		m.ResetTasks()
		return nil
	case param.EdgeSteps:
		m.ResetSteps()
		return nil
	case param.EdgeTaskParams:
		m.ResetTaskParams()
		return nil
	case param.EdgeStepParams:
		m.ResetStepParams()
		return nil
	}
	return fmt.Errorf("unknown Param edge %s", name)
}

// StepMutation represents an operation that mutates the Step nodes in the graph.
type StepMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uint64
	created_at             *time.Time
	updated_at             *time.Time
	created_by             *string
	updated_by             *string
	name                   *string
	desc                   *string
	kind                   *string
	content                *string
	timeout                *int64
	addtimeout             *int64
	action                 *string
	rule                   *string
	retry_policy           **schema.RetryPolicy
	metadata               *map[string]interface{}
	clearedFields          map[string]struct{}
	tasks                  map[uint64]struct{}
	removedtasks           map[uint64]struct{}
	clearedtasks           bool
	params                 map[uint64]struct{}
	removedparams          map[uint64]struct{}
	clearedparams          bool
	dependencies           map[uint64]struct{}
	removeddependencies    map[uint64]struct{}
	cleareddependencies    bool
	dependents             map[uint64]struct{}
	removeddependents      map[uint64]struct{}
	cleareddependents      bool
	task_steps             map[uint64]struct{}
	removedtask_steps      map[uint64]struct{}
	clearedtask_steps      bool
	step_params            map[uint64]struct{}
	removedstep_params     map[uint64]struct{}
	clearedstep_params     bool
	step_depends           map[uint64]struct{}
	removedstep_depends    map[uint64]struct{}
	clearedstep_depends    bool
	step_dependents        map[uint64]struct{}
	removedstep_dependents map[uint64]struct{}
	clearedstep_dependents bool
	done                   bool
	oldValue               func(context.Context) (*Step, error)
	predicates             []predicate.Step
}

var _ ent.Mutation = (*StepMutation)(nil)

// stepOption allows management of the mutation configuration using functional options.
type stepOption func(*StepMutation)

// newStepMutation creates new mutation for the Step entity.
func newStepMutation(c config, op Op, opts ...stepOption) *StepMutation {
	m := &StepMutation{
		config:        c,
		op:            op,
		typ:           TypeStep,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStepID sets the ID field of the mutation.
func withStepID(id uint64) stepOption {
	return func(m *StepMutation) {
		var (
			err   error
			once  sync.Once
			value *Step
		)
		m.oldValue = func(ctx context.Context) (*Step, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Step.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStep sets the old Step of the mutation.
func withStep(node *Step) stepOption {
	return func(m *StepMutation) {
		m.oldValue = func(context.Context) (*Step, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StepMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StepMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entv1: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Step entities.
func (m *StepMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StepMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StepMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Step.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *StepMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StepMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Step entity.
// If the Step object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *StepMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[step.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *StepMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[step.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StepMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, step.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StepMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StepMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Step entity.
// If the Step object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *StepMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[step.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *StepMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[step.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StepMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, step.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *StepMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *StepMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Step entity.
// If the Step object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepMutation) OldCreatedBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *StepMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[step.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *StepMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[step.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *StepMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, step.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *StepMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *StepMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Step entity.
// If the Step object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepMutation) OldUpdatedBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *StepMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[step.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *StepMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[step.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *StepMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, step.FieldUpdatedBy)
}

// SetName sets the "name" field.
func (m *StepMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StepMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Step entity.
// If the Step object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StepMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *StepMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *StepMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Step entity.
// If the Step object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepMutation) OldDesc(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ClearDesc clears the value of the "desc" field.
func (m *StepMutation) ClearDesc() {
	m.desc = nil
	m.clearedFields[step.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *StepMutation) DescCleared() bool {
	_, ok := m.clearedFields[step.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *StepMutation) ResetDesc() {
	m.desc = nil
	delete(m.clearedFields, step.FieldDesc)
}

// SetKind sets the "kind" field.
func (m *StepMutation) SetKind(s string) {
	m.kind = &s
}

// Kind returns the value of the "kind" field in the mutation.
func (m *StepMutation) Kind() (r string, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the Step entity.
// If the Step object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepMutation) OldKind(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ClearKind clears the value of the "kind" field.
func (m *StepMutation) ClearKind() {
	m.kind = nil
	m.clearedFields[step.FieldKind] = struct{}{}
}

// KindCleared returns if the "kind" field was cleared in this mutation.
func (m *StepMutation) KindCleared() bool {
	_, ok := m.clearedFields[step.FieldKind]
	return ok
}

// ResetKind resets all changes to the "kind" field.
func (m *StepMutation) ResetKind() {
	m.kind = nil
	delete(m.clearedFields, step.FieldKind)
}

// SetContent sets the "content" field.
func (m *StepMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *StepMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Step entity.
// If the Step object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepMutation) OldContent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *StepMutation) ClearContent() {
	m.content = nil
	m.clearedFields[step.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *StepMutation) ContentCleared() bool {
	_, ok := m.clearedFields[step.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *StepMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, step.FieldContent)
}

// SetTimeout sets the "timeout" field.
func (m *StepMutation) SetTimeout(i int64) {
	m.timeout = &i
	m.addtimeout = nil
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *StepMutation) Timeout() (r int64, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the Step entity.
// If the Step object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepMutation) OldTimeout(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// AddTimeout adds i to the "timeout" field.
func (m *StepMutation) AddTimeout(i int64) {
	if m.addtimeout != nil {
		*m.addtimeout += i
	} else {
		m.addtimeout = &i
	}
}

// AddedTimeout returns the value that was added to the "timeout" field in this mutation.
func (m *StepMutation) AddedTimeout() (r int64, exists bool) {
	v := m.addtimeout
	if v == nil {
		return
	}
	return *v, true
}

// ClearTimeout clears the value of the "timeout" field.
func (m *StepMutation) ClearTimeout() {
	m.timeout = nil
	m.addtimeout = nil
	m.clearedFields[step.FieldTimeout] = struct{}{}
}

// TimeoutCleared returns if the "timeout" field was cleared in this mutation.
func (m *StepMutation) TimeoutCleared() bool {
	_, ok := m.clearedFields[step.FieldTimeout]
	return ok
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *StepMutation) ResetTimeout() {
	m.timeout = nil
	m.addtimeout = nil
	delete(m.clearedFields, step.FieldTimeout)
}

// SetAction sets the "action" field.
func (m *StepMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *StepMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the Step entity.
// If the Step object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepMutation) OldAction(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ClearAction clears the value of the "action" field.
func (m *StepMutation) ClearAction() {
	m.action = nil
	m.clearedFields[step.FieldAction] = struct{}{}
}

// ActionCleared returns if the "action" field was cleared in this mutation.
func (m *StepMutation) ActionCleared() bool {
	_, ok := m.clearedFields[step.FieldAction]
	return ok
}

// ResetAction resets all changes to the "action" field.
func (m *StepMutation) ResetAction() {
	m.action = nil
	delete(m.clearedFields, step.FieldAction)
}

// SetRule sets the "rule" field.
func (m *StepMutation) SetRule(s string) {
	m.rule = &s
}

// Rule returns the value of the "rule" field in the mutation.
func (m *StepMutation) Rule() (r string, exists bool) {
	v := m.rule
	if v == nil {
		return
	}
	return *v, true
}

// OldRule returns the old "rule" field's value of the Step entity.
// If the Step object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepMutation) OldRule(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRule: %w", err)
	}
	return oldValue.Rule, nil
}

// ClearRule clears the value of the "rule" field.
func (m *StepMutation) ClearRule() {
	m.rule = nil
	m.clearedFields[step.FieldRule] = struct{}{}
}

// RuleCleared returns if the "rule" field was cleared in this mutation.
func (m *StepMutation) RuleCleared() bool {
	_, ok := m.clearedFields[step.FieldRule]
	return ok
}

// ResetRule resets all changes to the "rule" field.
func (m *StepMutation) ResetRule() {
	m.rule = nil
	delete(m.clearedFields, step.FieldRule)
}

// SetRetryPolicy sets the "retry_policy" field.
func (m *StepMutation) SetRetryPolicy(sp *schema.RetryPolicy) {
	m.retry_policy = &sp
}

// RetryPolicy returns the value of the "retry_policy" field in the mutation.
func (m *StepMutation) RetryPolicy() (r *schema.RetryPolicy, exists bool) {
	v := m.retry_policy
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryPolicy returns the old "retry_policy" field's value of the Step entity.
// If the Step object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepMutation) OldRetryPolicy(ctx context.Context) (v *schema.RetryPolicy, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryPolicy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryPolicy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryPolicy: %w", err)
	}
	return oldValue.RetryPolicy, nil
}

// ClearRetryPolicy clears the value of the "retry_policy" field.
func (m *StepMutation) ClearRetryPolicy() {
	m.retry_policy = nil
	m.clearedFields[step.FieldRetryPolicy] = struct{}{}
}

// RetryPolicyCleared returns if the "retry_policy" field was cleared in this mutation.
func (m *StepMutation) RetryPolicyCleared() bool {
	_, ok := m.clearedFields[step.FieldRetryPolicy]
	return ok
}

// ResetRetryPolicy resets all changes to the "retry_policy" field.
func (m *StepMutation) ResetRetryPolicy() {
	m.retry_policy = nil
	delete(m.clearedFields, step.FieldRetryPolicy)
}

// SetMetadata sets the "metadata" field.
func (m *StepMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *StepMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Step entity.
// If the Step object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *StepMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[step.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *StepMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[step.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *StepMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, step.FieldMetadata)
}

// AddTaskIDs adds the "tasks" edge to the Task entity by ids.
func (m *StepMutation) AddTaskIDs(ids ...uint64) {
	if m.tasks == nil {
		m.tasks = make(map[uint64]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the Task entity.
func (m *StepMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the Task entity was cleared.
func (m *StepMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the Task entity by IDs.
func (m *StepMutation) RemoveTaskIDs(ids ...uint64) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the Task entity.
func (m *StepMutation) RemovedTasksIDs() (ids []uint64) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *StepMutation) TasksIDs() (ids []uint64) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *StepMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// AddParamIDs adds the "params" edge to the Param entity by ids.
func (m *StepMutation) AddParamIDs(ids ...uint64) {
	if m.params == nil {
		m.params = make(map[uint64]struct{})
	}
	for i := range ids {
		m.params[ids[i]] = struct{}{}
	}
}

// ClearParams clears the "params" edge to the Param entity.
func (m *StepMutation) ClearParams() {
	m.clearedparams = true
}

// ParamsCleared reports if the "params" edge to the Param entity was cleared.
func (m *StepMutation) ParamsCleared() bool {
	return m.clearedparams
}

// RemoveParamIDs removes the "params" edge to the Param entity by IDs.
func (m *StepMutation) RemoveParamIDs(ids ...uint64) {
	if m.removedparams == nil {
		m.removedparams = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.params, ids[i])
		m.removedparams[ids[i]] = struct{}{}
	}
}

// RemovedParams returns the removed IDs of the "params" edge to the Param entity.
func (m *StepMutation) RemovedParamsIDs() (ids []uint64) {
	for id := range m.removedparams {
		ids = append(ids, id)
	}
	return
}

// ParamsIDs returns the "params" edge IDs in the mutation.
func (m *StepMutation) ParamsIDs() (ids []uint64) {
	for id := range m.params {
		ids = append(ids, id)
	}
	return
}

// ResetParams resets all changes to the "params" edge.
func (m *StepMutation) ResetParams() {
	m.params = nil
	m.clearedparams = false
	m.removedparams = nil
}

// AddDependencyIDs adds the "dependencies" edge to the Step entity by ids.
func (m *StepMutation) AddDependencyIDs(ids ...uint64) {
	if m.dependencies == nil {
		m.dependencies = make(map[uint64]struct{})
	}
	for i := range ids {
		m.dependencies[ids[i]] = struct{}{}
	}
}

// ClearDependencies clears the "dependencies" edge to the Step entity.
func (m *StepMutation) ClearDependencies() {
	m.cleareddependencies = true
}

// DependenciesCleared reports if the "dependencies" edge to the Step entity was cleared.
func (m *StepMutation) DependenciesCleared() bool {
	return m.cleareddependencies
}

// RemoveDependencyIDs removes the "dependencies" edge to the Step entity by IDs.
func (m *StepMutation) RemoveDependencyIDs(ids ...uint64) {
	if m.removeddependencies == nil {
		m.removeddependencies = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.dependencies, ids[i])
		m.removeddependencies[ids[i]] = struct{}{}
	}
}

// RemovedDependencies returns the removed IDs of the "dependencies" edge to the Step entity.
func (m *StepMutation) RemovedDependenciesIDs() (ids []uint64) {
	for id := range m.removeddependencies {
		ids = append(ids, id)
	}
	return
}

// DependenciesIDs returns the "dependencies" edge IDs in the mutation.
func (m *StepMutation) DependenciesIDs() (ids []uint64) {
	for id := range m.dependencies {
		ids = append(ids, id)
	}
	return
}

// ResetDependencies resets all changes to the "dependencies" edge.
func (m *StepMutation) ResetDependencies() {
	m.dependencies = nil
	m.cleareddependencies = false
	m.removeddependencies = nil
}

// AddDependentIDs adds the "dependents" edge to the Step entity by ids.
func (m *StepMutation) AddDependentIDs(ids ...uint64) {
	if m.dependents == nil {
		m.dependents = make(map[uint64]struct{})
	}
	for i := range ids {
		m.dependents[ids[i]] = struct{}{}
	}
}

// ClearDependents clears the "dependents" edge to the Step entity.
func (m *StepMutation) ClearDependents() {
	m.cleareddependents = true
}

// DependentsCleared reports if the "dependents" edge to the Step entity was cleared.
func (m *StepMutation) DependentsCleared() bool {
	return m.cleareddependents
}

// RemoveDependentIDs removes the "dependents" edge to the Step entity by IDs.
func (m *StepMutation) RemoveDependentIDs(ids ...uint64) {
	if m.removeddependents == nil {
		m.removeddependents = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.dependents, ids[i])
		m.removeddependents[ids[i]] = struct{}{}
	}
}

// RemovedDependents returns the removed IDs of the "dependents" edge to the Step entity.
func (m *StepMutation) RemovedDependentsIDs() (ids []uint64) {
	for id := range m.removeddependents {
		ids = append(ids, id)
	}
	return
}

// DependentsIDs returns the "dependents" edge IDs in the mutation.
func (m *StepMutation) DependentsIDs() (ids []uint64) {
	for id := range m.dependents {
		ids = append(ids, id)
	}
	return
}

// ResetDependents resets all changes to the "dependents" edge.
func (m *StepMutation) ResetDependents() {
	m.dependents = nil
	m.cleareddependents = false
	m.removeddependents = nil
}

// AddTaskStepIDs adds the "task_steps" edge to the TaskStep entity by ids.
func (m *StepMutation) AddTaskStepIDs(ids ...uint64) {
	if m.task_steps == nil {
		m.task_steps = make(map[uint64]struct{})
	}
	for i := range ids {
		m.task_steps[ids[i]] = struct{}{}
	}
}

// ClearTaskSteps clears the "task_steps" edge to the TaskStep entity.
func (m *StepMutation) ClearTaskSteps() {
	m.clearedtask_steps = true
}

// TaskStepsCleared reports if the "task_steps" edge to the TaskStep entity was cleared.
func (m *StepMutation) TaskStepsCleared() bool {
	return m.clearedtask_steps
}

// RemoveTaskStepIDs removes the "task_steps" edge to the TaskStep entity by IDs.
func (m *StepMutation) RemoveTaskStepIDs(ids ...uint64) {
	if m.removedtask_steps == nil {
		m.removedtask_steps = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.task_steps, ids[i])
		m.removedtask_steps[ids[i]] = struct{}{}
	}
}

// RemovedTaskSteps returns the removed IDs of the "task_steps" edge to the TaskStep entity.
func (m *StepMutation) RemovedTaskStepsIDs() (ids []uint64) {
	for id := range m.removedtask_steps {
		ids = append(ids, id)
	}
	return
}

// TaskStepsIDs returns the "task_steps" edge IDs in the mutation.
func (m *StepMutation) TaskStepsIDs() (ids []uint64) {
	for id := range m.task_steps {
		ids = append(ids, id)
	}
	return
}

// ResetTaskSteps resets all changes to the "task_steps" edge.
func (m *StepMutation) ResetTaskSteps() {
	m.task_steps = nil
	m.clearedtask_steps = false
	m.removedtask_steps = nil
}

// AddStepParamIDs adds the "step_params" edge to the StepParam entity by ids.
func (m *StepMutation) AddStepParamIDs(ids ...uint64) {
	if m.step_params == nil {
		m.step_params = make(map[uint64]struct{})
	}
	for i := range ids {
		m.step_params[ids[i]] = struct{}{}
	}
}

// ClearStepParams clears the "step_params" edge to the StepParam entity.
func (m *StepMutation) ClearStepParams() {
	m.clearedstep_params = true
}

// StepParamsCleared reports if the "step_params" edge to the StepParam entity was cleared.
func (m *StepMutation) StepParamsCleared() bool {
	return m.clearedstep_params
}

// RemoveStepParamIDs removes the "step_params" edge to the StepParam entity by IDs.
func (m *StepMutation) RemoveStepParamIDs(ids ...uint64) {
	if m.removedstep_params == nil {
		m.removedstep_params = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.step_params, ids[i])
		m.removedstep_params[ids[i]] = struct{}{}
	}
}

// RemovedStepParams returns the removed IDs of the "step_params" edge to the StepParam entity.
func (m *StepMutation) RemovedStepParamsIDs() (ids []uint64) {
	for id := range m.removedstep_params {
		ids = append(ids, id)
	}
	return
}

// StepParamsIDs returns the "step_params" edge IDs in the mutation.
func (m *StepMutation) StepParamsIDs() (ids []uint64) {
	for id := range m.step_params {
		ids = append(ids, id)
	}
	return
}

// ResetStepParams resets all changes to the "step_params" edge.
func (m *StepMutation) ResetStepParams() {
	m.step_params = nil
	m.clearedstep_params = false
	m.removedstep_params = nil
}

// AddStepDependIDs adds the "step_depends" edge to the StepDepend entity by ids.
func (m *StepMutation) AddStepDependIDs(ids ...uint64) {
	if m.step_depends == nil {
		m.step_depends = make(map[uint64]struct{})
	}
	for i := range ids {
		m.step_depends[ids[i]] = struct{}{}
	}
}

// ClearStepDepends clears the "step_depends" edge to the StepDepend entity.
func (m *StepMutation) ClearStepDepends() {
	m.clearedstep_depends = true
}

// StepDependsCleared reports if the "step_depends" edge to the StepDepend entity was cleared.
func (m *StepMutation) StepDependsCleared() bool {
	return m.clearedstep_depends
}

// RemoveStepDependIDs removes the "step_depends" edge to the StepDepend entity by IDs.
func (m *StepMutation) RemoveStepDependIDs(ids ...uint64) {
	if m.removedstep_depends == nil {
		m.removedstep_depends = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.step_depends, ids[i])
		m.removedstep_depends[ids[i]] = struct{}{}
	}
}

// RemovedStepDepends returns the removed IDs of the "step_depends" edge to the StepDepend entity.
func (m *StepMutation) RemovedStepDependsIDs() (ids []uint64) {
	for id := range m.removedstep_depends {
		ids = append(ids, id)
	}
	return
}

// StepDependsIDs returns the "step_depends" edge IDs in the mutation.
func (m *StepMutation) StepDependsIDs() (ids []uint64) {
	for id := range m.step_depends {
		ids = append(ids, id)
	}
	return
}

// ResetStepDepends resets all changes to the "step_depends" edge.
func (m *StepMutation) ResetStepDepends() {
	m.step_depends = nil
	m.clearedstep_depends = false
	m.removedstep_depends = nil
}

// AddStepDependentIDs adds the "step_dependents" edge to the StepDepend entity by ids.
func (m *StepMutation) AddStepDependentIDs(ids ...uint64) {
	if m.step_dependents == nil {
		m.step_dependents = make(map[uint64]struct{})
	}
	for i := range ids {
		m.step_dependents[ids[i]] = struct{}{}
	}
}

// ClearStepDependents clears the "step_dependents" edge to the StepDepend entity.
func (m *StepMutation) ClearStepDependents() {
	m.clearedstep_dependents = true
}

// StepDependentsCleared reports if the "step_dependents" edge to the StepDepend entity was cleared.
func (m *StepMutation) StepDependentsCleared() bool {
	return m.clearedstep_dependents
}

// RemoveStepDependentIDs removes the "step_dependents" edge to the StepDepend entity by IDs.
func (m *StepMutation) RemoveStepDependentIDs(ids ...uint64) {
	if m.removedstep_dependents == nil {
		m.removedstep_dependents = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.step_dependents, ids[i])
		m.removedstep_dependents[ids[i]] = struct{}{}
	}
}

// RemovedStepDependents returns the removed IDs of the "step_dependents" edge to the StepDepend entity.
func (m *StepMutation) RemovedStepDependentsIDs() (ids []uint64) {
	for id := range m.removedstep_dependents {
		ids = append(ids, id)
	}
	return
}

// StepDependentsIDs returns the "step_dependents" edge IDs in the mutation.
func (m *StepMutation) StepDependentsIDs() (ids []uint64) {
	for id := range m.step_dependents {
		ids = append(ids, id)
	}
	return
}

// ResetStepDependents resets all changes to the "step_dependents" edge.
func (m *StepMutation) ResetStepDependents() {
	m.step_dependents = nil
	m.clearedstep_dependents = false
	m.removedstep_dependents = nil
}

// Where appends a list predicates to the StepMutation builder.
func (m *StepMutation) Where(ps ...predicate.Step) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StepMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StepMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Step, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StepMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StepMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Step).
func (m *StepMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StepMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, step.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, step.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, step.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, step.FieldUpdatedBy)
	}
	if m.name != nil {
		fields = append(fields, step.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, step.FieldDesc)
	}
	if m.kind != nil {
		fields = append(fields, step.FieldKind)
	}
	if m.content != nil {
		fields = append(fields, step.FieldContent)
	}
	if m.timeout != nil {
		fields = append(fields, step.FieldTimeout)
	}
	if m.action != nil {
		fields = append(fields, step.FieldAction)
	}
	if m.rule != nil {
		fields = append(fields, step.FieldRule)
	}
	if m.retry_policy != nil {
		fields = append(fields, step.FieldRetryPolicy)
	}
	if m.metadata != nil {
		fields = append(fields, step.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StepMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case step.FieldCreatedAt:
		return m.CreatedAt()
	case step.FieldUpdatedAt:
		return m.UpdatedAt()
	case step.FieldCreatedBy:
		return m.CreatedBy()
	case step.FieldUpdatedBy:
		return m.UpdatedBy()
	case step.FieldName:
		return m.Name()
	case step.FieldDesc:
		return m.Desc()
	case step.FieldKind:
		return m.Kind()
	case step.FieldContent:
		return m.Content()
	case step.FieldTimeout:
		return m.Timeout()
	case step.FieldAction:
		return m.Action()
	case step.FieldRule:
		return m.Rule()
	case step.FieldRetryPolicy:
		return m.RetryPolicy()
	case step.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StepMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case step.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case step.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case step.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case step.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case step.FieldName:
		return m.OldName(ctx)
	case step.FieldDesc:
		return m.OldDesc(ctx)
	case step.FieldKind:
		return m.OldKind(ctx)
	case step.FieldContent:
		return m.OldContent(ctx)
	case step.FieldTimeout:
		return m.OldTimeout(ctx)
	case step.FieldAction:
		return m.OldAction(ctx)
	case step.FieldRule:
		return m.OldRule(ctx)
	case step.FieldRetryPolicy:
		return m.OldRetryPolicy(ctx)
	case step.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown Step field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StepMutation) SetField(name string, value ent.Value) error {
	switch name {
	case step.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case step.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case step.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case step.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case step.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case step.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case step.FieldKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case step.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case step.FieldTimeout:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case step.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case step.FieldRule:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRule(v)
		return nil
	case step.FieldRetryPolicy:
		v, ok := value.(*schema.RetryPolicy)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryPolicy(v)
		return nil
	case step.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown Step field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StepMutation) AddedFields() []string {
	var fields []string
	if m.addtimeout != nil {
		fields = append(fields, step.FieldTimeout)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StepMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case step.FieldTimeout:
		return m.AddedTimeout()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StepMutation) AddField(name string, value ent.Value) error {
	switch name {
	case step.FieldTimeout:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeout(v)
		return nil
	}
	return fmt.Errorf("unknown Step numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StepMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(step.FieldCreatedAt) {
		fields = append(fields, step.FieldCreatedAt)
	}
	if m.FieldCleared(step.FieldUpdatedAt) {
		fields = append(fields, step.FieldUpdatedAt)
	}
	if m.FieldCleared(step.FieldCreatedBy) {
		fields = append(fields, step.FieldCreatedBy)
	}
	if m.FieldCleared(step.FieldUpdatedBy) {
		fields = append(fields, step.FieldUpdatedBy)
	}
	if m.FieldCleared(step.FieldDesc) {
		fields = append(fields, step.FieldDesc)
	}
	if m.FieldCleared(step.FieldKind) {
		fields = append(fields, step.FieldKind)
	}
	if m.FieldCleared(step.FieldContent) {
		fields = append(fields, step.FieldContent)
	}
	if m.FieldCleared(step.FieldTimeout) {
		fields = append(fields, step.FieldTimeout)
	}
	if m.FieldCleared(step.FieldAction) {
		fields = append(fields, step.FieldAction)
	}
	if m.FieldCleared(step.FieldRule) {
		fields = append(fields, step.FieldRule)
	}
	if m.FieldCleared(step.FieldRetryPolicy) {
		fields = append(fields, step.FieldRetryPolicy)
	}
	if m.FieldCleared(step.FieldMetadata) {
		fields = append(fields, step.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StepMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StepMutation) ClearField(name string) error {
	switch name {
	case step.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case step.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case step.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case step.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case step.FieldDesc:
		m.ClearDesc()
		return nil
	case step.FieldKind:
		m.ClearKind()
		return nil
	case step.FieldContent:
		m.ClearContent()
		return nil
	case step.FieldTimeout:
		m.ClearTimeout()
		return nil
	case step.FieldAction:
		m.ClearAction()
		return nil
	case step.FieldRule:
		m.ClearRule()
		return nil
	case step.FieldRetryPolicy:
		m.ClearRetryPolicy()
		return nil
	case step.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Step nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StepMutation) ResetField(name string) error {
	switch name {
	case step.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case step.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case step.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case step.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case step.FieldName:
		m.ResetName()
		return nil
	case step.FieldDesc:
		m.ResetDesc()
		return nil
	case step.FieldKind:
		m.ResetKind()
		return nil
	case step.FieldContent:
		m.ResetContent()
		return nil
	case step.FieldTimeout:
		m.ResetTimeout()
		return nil
	case step.FieldAction:
		m.ResetAction()
		return nil
	case step.FieldRule:
		m.ResetRule()
		return nil
	case step.FieldRetryPolicy:
		m.ResetRetryPolicy()
		return nil
	case step.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown Step field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StepMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.tasks != nil {
		edges = append(edges, step.EdgeTasks)
	}
	if m.params != nil {
		edges = append(edges, step.EdgeParams)
	}
	if m.dependencies != nil {
		edges = append(edges, step.EdgeDependencies)
	}
	if m.dependents != nil {
		edges = append(edges, step.EdgeDependents)
	}
	if m.task_steps != nil {
		edges = append(edges, step.EdgeTaskSteps)
	}
	if m.step_params != nil {
		edges = append(edges, step.EdgeStepParams)
	}
	if m.step_depends != nil {
		edges = append(edges, step.EdgeStepDepends)
	}
	if m.step_dependents != nil {
		edges = append(edges, step.EdgeStepDependents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StepMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case step.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	case step.EdgeParams:
		ids := make([]ent.Value, 0, len(m.params))
		for id := range m.params {
			ids = append(ids, id)
		}
		return ids
	case step.EdgeDependencies:
		ids := make([]ent.Value, 0, len(m.dependencies))
		for id := range m.dependencies {
			ids = append(ids, id)
		}
		return ids
	case step.EdgeDependents:
		ids := make([]ent.Value, 0, len(m.dependents))
		for id := range m.dependents {
			ids = append(ids, id)
		}
		return ids
	case step.EdgeTaskSteps:
		ids := make([]ent.Value, 0, len(m.task_steps))
		for id := range m.task_steps {
			ids = append(ids, id)
		}
		return ids
	case step.EdgeStepParams:
		ids := make([]ent.Value, 0, len(m.step_params))
		for id := range m.step_params {
			ids = append(ids, id)
		}
		return ids
	case step.EdgeStepDepends:
		ids := make([]ent.Value, 0, len(m.step_depends))
		for id := range m.step_depends {
			ids = append(ids, id)
		}
		return ids
	case step.EdgeStepDependents:
		ids := make([]ent.Value, 0, len(m.step_dependents))
		for id := range m.step_dependents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StepMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedtasks != nil {
		edges = append(edges, step.EdgeTasks)
	}
	if m.removedparams != nil {
		edges = append(edges, step.EdgeParams)
	}
	if m.removeddependencies != nil {
		edges = append(edges, step.EdgeDependencies)
	}
	if m.removeddependents != nil {
		edges = append(edges, step.EdgeDependents)
	}
	if m.removedtask_steps != nil {
		edges = append(edges, step.EdgeTaskSteps)
	}
	if m.removedstep_params != nil {
		edges = append(edges, step.EdgeStepParams)
	}
	if m.removedstep_depends != nil {
		edges = append(edges, step.EdgeStepDepends)
	}
	if m.removedstep_dependents != nil {
		edges = append(edges, step.EdgeStepDependents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StepMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case step.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	case step.EdgeParams:
		ids := make([]ent.Value, 0, len(m.removedparams))
		for id := range m.removedparams {
			ids = append(ids, id)
		}
		return ids
	case step.EdgeDependencies:
		ids := make([]ent.Value, 0, len(m.removeddependencies))
		for id := range m.removeddependencies {
			ids = append(ids, id)
		}
		return ids
	case step.EdgeDependents:
		ids := make([]ent.Value, 0, len(m.removeddependents))
		for id := range m.removeddependents {
			ids = append(ids, id)
		}
		return ids
	case step.EdgeTaskSteps:
		ids := make([]ent.Value, 0, len(m.removedtask_steps))
		for id := range m.removedtask_steps {
			ids = append(ids, id)
		}
		return ids
	case step.EdgeStepParams:
		ids := make([]ent.Value, 0, len(m.removedstep_params))
		for id := range m.removedstep_params {
			ids = append(ids, id)
		}
		return ids
	case step.EdgeStepDepends:
		ids := make([]ent.Value, 0, len(m.removedstep_depends))
		for id := range m.removedstep_depends {
			ids = append(ids, id)
		}
		return ids
	case step.EdgeStepDependents:
		ids := make([]ent.Value, 0, len(m.removedstep_dependents))
		for id := range m.removedstep_dependents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StepMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedtasks {
		edges = append(edges, step.EdgeTasks)
	}
	if m.clearedparams {
		edges = append(edges, step.EdgeParams)
	}
	if m.cleareddependencies {
		edges = append(edges, step.EdgeDependencies)
	}
	if m.cleareddependents {
		edges = append(edges, step.EdgeDependents)
	}
	if m.clearedtask_steps {
		edges = append(edges, step.EdgeTaskSteps)
	}
	if m.clearedstep_params {
		edges = append(edges, step.EdgeStepParams)
	}
	if m.clearedstep_depends {
		edges = append(edges, step.EdgeStepDepends)
	}
	if m.clearedstep_dependents {
		edges = append(edges, step.EdgeStepDependents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StepMutation) EdgeCleared(name string) bool {
	switch name {
	case step.EdgeTasks:
		return m.clearedtasks
	case step.EdgeParams:
		return m.clearedparams
	case step.EdgeDependencies:
		return m.cleareddependencies
	case step.EdgeDependents:
		return m.cleareddependents
	case step.EdgeTaskSteps:
		return m.clearedtask_steps
	case step.EdgeStepParams:
		return m.clearedstep_params
	case step.EdgeStepDepends:
		return m.clearedstep_depends
	case step.EdgeStepDependents:
		return m.clearedstep_dependents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StepMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Step unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StepMutation) ResetEdge(name string) error {
	switch name {
	case step.EdgeTasks:
		m.ResetTasks()
		return nil
	case step.EdgeParams:
		m.ResetParams()
		return nil
	case step.EdgeDependencies:
		m.ResetDependencies()
		return nil
	case step.EdgeDependents:
		m.ResetDependents()
		return nil
	case step.EdgeTaskSteps:
		m.ResetTaskSteps()
		return nil
	case step.EdgeStepParams:
		m.ResetStepParams()
		return nil
	case step.EdgeStepDepends:
		m.ResetStepDepends()
		return nil
	case step.EdgeStepDependents:
		m.ResetStepDependents()
		return nil
	}
	return fmt.Errorf("unknown Step edge %s", name)
}

// StepDependMutation represents an operation that mutates the StepDepend nodes in the graph.
type StepDependMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint64
	created_at         *time.Time
	updated_at         *time.Time
	created_by         *string
	updated_by         *string
	clearedFields      map[string]struct{}
	step               *uint64
	clearedstep        bool
	depend_step        *uint64
	cleareddepend_step bool
	done               bool
	oldValue           func(context.Context) (*StepDepend, error)
	predicates         []predicate.StepDepend
}

var _ ent.Mutation = (*StepDependMutation)(nil)

// stepdependOption allows management of the mutation configuration using functional options.
type stepdependOption func(*StepDependMutation)

// newStepDependMutation creates new mutation for the StepDepend entity.
func newStepDependMutation(c config, op Op, opts ...stepdependOption) *StepDependMutation {
	m := &StepDependMutation{
		config:        c,
		op:            op,
		typ:           TypeStepDepend,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStepDependID sets the ID field of the mutation.
func withStepDependID(id uint64) stepdependOption {
	return func(m *StepDependMutation) {
		var (
			err   error
			once  sync.Once
			value *StepDepend
		)
		m.oldValue = func(ctx context.Context) (*StepDepend, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StepDepend.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStepDepend sets the old StepDepend of the mutation.
func withStepDepend(node *StepDepend) stepdependOption {
	return func(m *StepDependMutation) {
		m.oldValue = func(context.Context) (*StepDepend, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StepDependMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StepDependMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entv1: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of StepDepend entities.
func (m *StepDependMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StepDependMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StepDependMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StepDepend.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *StepDependMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StepDependMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the StepDepend entity.
// If the StepDepend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepDependMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *StepDependMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[stepdepend.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *StepDependMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[stepdepend.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StepDependMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, stepdepend.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StepDependMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StepDependMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the StepDepend entity.
// If the StepDepend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepDependMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *StepDependMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[stepdepend.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *StepDependMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[stepdepend.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StepDependMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, stepdepend.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *StepDependMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *StepDependMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the StepDepend entity.
// If the StepDepend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepDependMutation) OldCreatedBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *StepDependMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[stepdepend.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *StepDependMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[stepdepend.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *StepDependMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, stepdepend.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *StepDependMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *StepDependMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the StepDepend entity.
// If the StepDepend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepDependMutation) OldUpdatedBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *StepDependMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[stepdepend.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *StepDependMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[stepdepend.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *StepDependMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, stepdepend.FieldUpdatedBy)
}

// SetStepID sets the "step_id" field.
func (m *StepDependMutation) SetStepID(u uint64) {
	m.step = &u
}

// StepID returns the value of the "step_id" field in the mutation.
func (m *StepDependMutation) StepID() (r uint64, exists bool) {
	v := m.step
	if v == nil {
		return
	}
	return *v, true
}

// OldStepID returns the old "step_id" field's value of the StepDepend entity.
// If the StepDepend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepDependMutation) OldStepID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStepID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStepID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStepID: %w", err)
	}
	return oldValue.StepID, nil
}

// ResetStepID resets all changes to the "step_id" field.
func (m *StepDependMutation) ResetStepID() {
	m.step = nil
}

// SetDependentID sets the "dependent_id" field.
func (m *StepDependMutation) SetDependentID(u uint64) {
	m.depend_step = &u
}

// DependentID returns the value of the "dependent_id" field in the mutation.
func (m *StepDependMutation) DependentID() (r uint64, exists bool) {
	v := m.depend_step
	if v == nil {
		return
	}
	return *v, true
}

// OldDependentID returns the old "dependent_id" field's value of the StepDepend entity.
// If the StepDepend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepDependMutation) OldDependentID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDependentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDependentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDependentID: %w", err)
	}
	return oldValue.DependentID, nil
}

// ResetDependentID resets all changes to the "dependent_id" field.
func (m *StepDependMutation) ResetDependentID() {
	m.depend_step = nil
}

// ClearStep clears the "step" edge to the Step entity.
func (m *StepDependMutation) ClearStep() {
	m.clearedstep = true
	m.clearedFields[stepdepend.FieldStepID] = struct{}{}
}

// StepCleared reports if the "step" edge to the Step entity was cleared.
func (m *StepDependMutation) StepCleared() bool {
	return m.clearedstep
}

// StepIDs returns the "step" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StepID instead. It exists only for internal usage by the builders.
func (m *StepDependMutation) StepIDs() (ids []uint64) {
	if id := m.step; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStep resets all changes to the "step" edge.
func (m *StepDependMutation) ResetStep() {
	m.step = nil
	m.clearedstep = false
}

// SetDependStepID sets the "depend_step" edge to the Step entity by id.
func (m *StepDependMutation) SetDependStepID(id uint64) {
	m.depend_step = &id
}

// ClearDependStep clears the "depend_step" edge to the Step entity.
func (m *StepDependMutation) ClearDependStep() {
	m.cleareddepend_step = true
	m.clearedFields[stepdepend.FieldDependentID] = struct{}{}
}

// DependStepCleared reports if the "depend_step" edge to the Step entity was cleared.
func (m *StepDependMutation) DependStepCleared() bool {
	return m.cleareddepend_step
}

// DependStepID returns the "depend_step" edge ID in the mutation.
func (m *StepDependMutation) DependStepID() (id uint64, exists bool) {
	if m.depend_step != nil {
		return *m.depend_step, true
	}
	return
}

// DependStepIDs returns the "depend_step" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DependStepID instead. It exists only for internal usage by the builders.
func (m *StepDependMutation) DependStepIDs() (ids []uint64) {
	if id := m.depend_step; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDependStep resets all changes to the "depend_step" edge.
func (m *StepDependMutation) ResetDependStep() {
	m.depend_step = nil
	m.cleareddepend_step = false
}

// Where appends a list predicates to the StepDependMutation builder.
func (m *StepDependMutation) Where(ps ...predicate.StepDepend) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StepDependMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StepDependMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StepDepend, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StepDependMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StepDependMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StepDepend).
func (m *StepDependMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StepDependMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, stepdepend.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, stepdepend.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, stepdepend.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, stepdepend.FieldUpdatedBy)
	}
	if m.step != nil {
		fields = append(fields, stepdepend.FieldStepID)
	}
	if m.depend_step != nil {
		fields = append(fields, stepdepend.FieldDependentID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StepDependMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case stepdepend.FieldCreatedAt:
		return m.CreatedAt()
	case stepdepend.FieldUpdatedAt:
		return m.UpdatedAt()
	case stepdepend.FieldCreatedBy:
		return m.CreatedBy()
	case stepdepend.FieldUpdatedBy:
		return m.UpdatedBy()
	case stepdepend.FieldStepID:
		return m.StepID()
	case stepdepend.FieldDependentID:
		return m.DependentID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StepDependMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case stepdepend.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case stepdepend.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case stepdepend.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case stepdepend.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case stepdepend.FieldStepID:
		return m.OldStepID(ctx)
	case stepdepend.FieldDependentID:
		return m.OldDependentID(ctx)
	}
	return nil, fmt.Errorf("unknown StepDepend field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StepDependMutation) SetField(name string, value ent.Value) error {
	switch name {
	case stepdepend.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case stepdepend.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case stepdepend.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case stepdepend.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case stepdepend.FieldStepID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStepID(v)
		return nil
	case stepdepend.FieldDependentID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDependentID(v)
		return nil
	}
	return fmt.Errorf("unknown StepDepend field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StepDependMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StepDependMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StepDependMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown StepDepend numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StepDependMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(stepdepend.FieldCreatedAt) {
		fields = append(fields, stepdepend.FieldCreatedAt)
	}
	if m.FieldCleared(stepdepend.FieldUpdatedAt) {
		fields = append(fields, stepdepend.FieldUpdatedAt)
	}
	if m.FieldCleared(stepdepend.FieldCreatedBy) {
		fields = append(fields, stepdepend.FieldCreatedBy)
	}
	if m.FieldCleared(stepdepend.FieldUpdatedBy) {
		fields = append(fields, stepdepend.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StepDependMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StepDependMutation) ClearField(name string) error {
	switch name {
	case stepdepend.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case stepdepend.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case stepdepend.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case stepdepend.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown StepDepend nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StepDependMutation) ResetField(name string) error {
	switch name {
	case stepdepend.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case stepdepend.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case stepdepend.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case stepdepend.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case stepdepend.FieldStepID:
		m.ResetStepID()
		return nil
	case stepdepend.FieldDependentID:
		m.ResetDependentID()
		return nil
	}
	return fmt.Errorf("unknown StepDepend field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StepDependMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.step != nil {
		edges = append(edges, stepdepend.EdgeStep)
	}
	if m.depend_step != nil {
		edges = append(edges, stepdepend.EdgeDependStep)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StepDependMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case stepdepend.EdgeStep:
		if id := m.step; id != nil {
			return []ent.Value{*id}
		}
	case stepdepend.EdgeDependStep:
		if id := m.depend_step; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StepDependMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StepDependMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StepDependMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedstep {
		edges = append(edges, stepdepend.EdgeStep)
	}
	if m.cleareddepend_step {
		edges = append(edges, stepdepend.EdgeDependStep)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StepDependMutation) EdgeCleared(name string) bool {
	switch name {
	case stepdepend.EdgeStep:
		return m.clearedstep
	case stepdepend.EdgeDependStep:
		return m.cleareddepend_step
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StepDependMutation) ClearEdge(name string) error {
	switch name {
	case stepdepend.EdgeStep:
		m.ClearStep()
		return nil
	case stepdepend.EdgeDependStep:
		m.ClearDependStep()
		return nil
	}
	return fmt.Errorf("unknown StepDepend unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StepDependMutation) ResetEdge(name string) error {
	switch name {
	case stepdepend.EdgeStep:
		m.ResetStep()
		return nil
	case stepdepend.EdgeDependStep:
		m.ResetDependStep()
		return nil
	}
	return fmt.Errorf("unknown StepDepend edge %s", name)
}

// StepParamMutation represents an operation that mutates the StepParam nodes in the graph.
type StepParamMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	created_by    *string
	updated_by    *string
	clearedFields map[string]struct{}
	step          *uint64
	clearedstep   bool
	param         *uint64
	clearedparam  bool
	done          bool
	oldValue      func(context.Context) (*StepParam, error)
	predicates    []predicate.StepParam
}

var _ ent.Mutation = (*StepParamMutation)(nil)

// stepparamOption allows management of the mutation configuration using functional options.
type stepparamOption func(*StepParamMutation)

// newStepParamMutation creates new mutation for the StepParam entity.
func newStepParamMutation(c config, op Op, opts ...stepparamOption) *StepParamMutation {
	m := &StepParamMutation{
		config:        c,
		op:            op,
		typ:           TypeStepParam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStepParamID sets the ID field of the mutation.
func withStepParamID(id uint64) stepparamOption {
	return func(m *StepParamMutation) {
		var (
			err   error
			once  sync.Once
			value *StepParam
		)
		m.oldValue = func(ctx context.Context) (*StepParam, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StepParam.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStepParam sets the old StepParam of the mutation.
func withStepParam(node *StepParam) stepparamOption {
	return func(m *StepParamMutation) {
		m.oldValue = func(context.Context) (*StepParam, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StepParamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StepParamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entv1: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of StepParam entities.
func (m *StepParamMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StepParamMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StepParamMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StepParam.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *StepParamMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StepParamMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the StepParam entity.
// If the StepParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepParamMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *StepParamMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[stepparam.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *StepParamMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[stepparam.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StepParamMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, stepparam.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StepParamMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StepParamMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the StepParam entity.
// If the StepParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepParamMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *StepParamMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[stepparam.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *StepParamMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[stepparam.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StepParamMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, stepparam.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *StepParamMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *StepParamMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the StepParam entity.
// If the StepParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepParamMutation) OldCreatedBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *StepParamMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[stepparam.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *StepParamMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[stepparam.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *StepParamMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, stepparam.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *StepParamMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *StepParamMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the StepParam entity.
// If the StepParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepParamMutation) OldUpdatedBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *StepParamMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[stepparam.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *StepParamMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[stepparam.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *StepParamMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, stepparam.FieldUpdatedBy)
}

// SetStepID sets the "step_id" field.
func (m *StepParamMutation) SetStepID(u uint64) {
	m.step = &u
}

// StepID returns the value of the "step_id" field in the mutation.
func (m *StepParamMutation) StepID() (r uint64, exists bool) {
	v := m.step
	if v == nil {
		return
	}
	return *v, true
}

// OldStepID returns the old "step_id" field's value of the StepParam entity.
// If the StepParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepParamMutation) OldStepID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStepID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStepID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStepID: %w", err)
	}
	return oldValue.StepID, nil
}

// ResetStepID resets all changes to the "step_id" field.
func (m *StepParamMutation) ResetStepID() {
	m.step = nil
}

// SetParamID sets the "param_id" field.
func (m *StepParamMutation) SetParamID(u uint64) {
	m.param = &u
}

// ParamID returns the value of the "param_id" field in the mutation.
func (m *StepParamMutation) ParamID() (r uint64, exists bool) {
	v := m.param
	if v == nil {
		return
	}
	return *v, true
}

// OldParamID returns the old "param_id" field's value of the StepParam entity.
// If the StepParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StepParamMutation) OldParamID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParamID: %w", err)
	}
	return oldValue.ParamID, nil
}

// ResetParamID resets all changes to the "param_id" field.
func (m *StepParamMutation) ResetParamID() {
	m.param = nil
}

// ClearStep clears the "step" edge to the Step entity.
func (m *StepParamMutation) ClearStep() {
	m.clearedstep = true
	m.clearedFields[stepparam.FieldStepID] = struct{}{}
}

// StepCleared reports if the "step" edge to the Step entity was cleared.
func (m *StepParamMutation) StepCleared() bool {
	return m.clearedstep
}

// StepIDs returns the "step" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StepID instead. It exists only for internal usage by the builders.
func (m *StepParamMutation) StepIDs() (ids []uint64) {
	if id := m.step; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStep resets all changes to the "step" edge.
func (m *StepParamMutation) ResetStep() {
	m.step = nil
	m.clearedstep = false
}

// ClearParam clears the "param" edge to the Param entity.
func (m *StepParamMutation) ClearParam() {
	m.clearedparam = true
	m.clearedFields[stepparam.FieldParamID] = struct{}{}
}

// ParamCleared reports if the "param" edge to the Param entity was cleared.
func (m *StepParamMutation) ParamCleared() bool {
	return m.clearedparam
}

// ParamIDs returns the "param" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParamID instead. It exists only for internal usage by the builders.
func (m *StepParamMutation) ParamIDs() (ids []uint64) {
	if id := m.param; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParam resets all changes to the "param" edge.
func (m *StepParamMutation) ResetParam() {
	m.param = nil
	m.clearedparam = false
}

// Where appends a list predicates to the StepParamMutation builder.
func (m *StepParamMutation) Where(ps ...predicate.StepParam) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StepParamMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StepParamMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StepParam, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StepParamMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StepParamMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StepParam).
func (m *StepParamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StepParamMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, stepparam.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, stepparam.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, stepparam.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, stepparam.FieldUpdatedBy)
	}
	if m.step != nil {
		fields = append(fields, stepparam.FieldStepID)
	}
	if m.param != nil {
		fields = append(fields, stepparam.FieldParamID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StepParamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case stepparam.FieldCreatedAt:
		return m.CreatedAt()
	case stepparam.FieldUpdatedAt:
		return m.UpdatedAt()
	case stepparam.FieldCreatedBy:
		return m.CreatedBy()
	case stepparam.FieldUpdatedBy:
		return m.UpdatedBy()
	case stepparam.FieldStepID:
		return m.StepID()
	case stepparam.FieldParamID:
		return m.ParamID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StepParamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case stepparam.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case stepparam.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case stepparam.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case stepparam.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case stepparam.FieldStepID:
		return m.OldStepID(ctx)
	case stepparam.FieldParamID:
		return m.OldParamID(ctx)
	}
	return nil, fmt.Errorf("unknown StepParam field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StepParamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case stepparam.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case stepparam.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case stepparam.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case stepparam.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case stepparam.FieldStepID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStepID(v)
		return nil
	case stepparam.FieldParamID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParamID(v)
		return nil
	}
	return fmt.Errorf("unknown StepParam field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StepParamMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StepParamMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StepParamMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown StepParam numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StepParamMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(stepparam.FieldCreatedAt) {
		fields = append(fields, stepparam.FieldCreatedAt)
	}
	if m.FieldCleared(stepparam.FieldUpdatedAt) {
		fields = append(fields, stepparam.FieldUpdatedAt)
	}
	if m.FieldCleared(stepparam.FieldCreatedBy) {
		fields = append(fields, stepparam.FieldCreatedBy)
	}
	if m.FieldCleared(stepparam.FieldUpdatedBy) {
		fields = append(fields, stepparam.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StepParamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StepParamMutation) ClearField(name string) error {
	switch name {
	case stepparam.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case stepparam.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case stepparam.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case stepparam.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown StepParam nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StepParamMutation) ResetField(name string) error {
	switch name {
	case stepparam.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case stepparam.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case stepparam.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case stepparam.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case stepparam.FieldStepID:
		m.ResetStepID()
		return nil
	case stepparam.FieldParamID:
		m.ResetParamID()
		return nil
	}
	return fmt.Errorf("unknown StepParam field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StepParamMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.step != nil {
		edges = append(edges, stepparam.EdgeStep)
	}
	if m.param != nil {
		edges = append(edges, stepparam.EdgeParam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StepParamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case stepparam.EdgeStep:
		if id := m.step; id != nil {
			return []ent.Value{*id}
		}
	case stepparam.EdgeParam:
		if id := m.param; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StepParamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StepParamMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StepParamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedstep {
		edges = append(edges, stepparam.EdgeStep)
	}
	if m.clearedparam {
		edges = append(edges, stepparam.EdgeParam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StepParamMutation) EdgeCleared(name string) bool {
	switch name {
	case stepparam.EdgeStep:
		return m.clearedstep
	case stepparam.EdgeParam:
		return m.clearedparam
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StepParamMutation) ClearEdge(name string) error {
	switch name {
	case stepparam.EdgeStep:
		m.ClearStep()
		return nil
	case stepparam.EdgeParam:
		m.ClearParam()
		return nil
	}
	return fmt.Errorf("unknown StepParam unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StepParamMutation) ResetEdge(name string) error {
	switch name {
	case stepparam.EdgeStep:
		m.ResetStep()
		return nil
	case stepparam.EdgeParam:
		m.ResetParam()
		return nil
	}
	return fmt.Errorf("unknown StepParam edge %s", name)
}

// TaskMutation represents an operation that mutates the Task nodes in the graph.
type TaskMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint64
	created_at         *time.Time
	updated_at         *time.Time
	created_by         *string
	updated_by         *string
	disabled           *bool
	message            *string
	state              *task.State
	previous_state     *task.PreviousState
	start_time         *time.Time
	end_time           *time.Time
	name               *string
	desc               *string
	kind               *string
	node               *string
	timeout            *int64
	addtimeout         *int64
	retry_policy       **schema.RetryPolicy
	is_tpl             *bool
	clearedFields      map[string]struct{}
	steps              map[uint64]struct{}
	removedsteps       map[uint64]struct{}
	clearedsteps       bool
	params             map[uint64]struct{}
	removedparams      map[uint64]struct{}
	clearedparams      bool
	task_steps         map[uint64]struct{}
	removedtask_steps  map[uint64]struct{}
	clearedtask_steps  bool
	task_params        map[uint64]struct{}
	removedtask_params map[uint64]struct{}
	clearedtask_params bool
	done               bool
	oldValue           func(context.Context) (*Task, error)
	predicates         []predicate.Task
}

var _ ent.Mutation = (*TaskMutation)(nil)

// taskOption allows management of the mutation configuration using functional options.
type taskOption func(*TaskMutation)

// newTaskMutation creates new mutation for the Task entity.
func newTaskMutation(c config, op Op, opts ...taskOption) *TaskMutation {
	m := &TaskMutation{
		config:        c,
		op:            op,
		typ:           TypeTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskID sets the ID field of the mutation.
func withTaskID(id uint64) taskOption {
	return func(m *TaskMutation) {
		var (
			err   error
			once  sync.Once
			value *Task
		)
		m.oldValue = func(ctx context.Context) (*Task, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Task.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTask sets the old Task of the mutation.
func withTask(node *Task) taskOption {
	return func(m *TaskMutation) {
		m.oldValue = func(context.Context) (*Task, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entv1: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Task entities.
func (m *TaskMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Task.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TaskMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[task.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TaskMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[task.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, task.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TaskMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[task.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TaskMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[task.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, task.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *TaskMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TaskMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreatedBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *TaskMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[task.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *TaskMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[task.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TaskMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, task.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TaskMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TaskMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldUpdatedBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *TaskMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[task.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *TaskMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[task.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TaskMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, task.FieldUpdatedBy)
}

// SetDisabled sets the "disabled" field.
func (m *TaskMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *TaskMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDisabled(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ClearDisabled clears the value of the "disabled" field.
func (m *TaskMutation) ClearDisabled() {
	m.disabled = nil
	m.clearedFields[task.FieldDisabled] = struct{}{}
}

// DisabledCleared returns if the "disabled" field was cleared in this mutation.
func (m *TaskMutation) DisabledCleared() bool {
	_, ok := m.clearedFields[task.FieldDisabled]
	return ok
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *TaskMutation) ResetDisabled() {
	m.disabled = nil
	delete(m.clearedFields, task.FieldDisabled)
}

// SetMessage sets the "message" field.
func (m *TaskMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *TaskMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldMessage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ClearMessage clears the value of the "message" field.
func (m *TaskMutation) ClearMessage() {
	m.message = nil
	m.clearedFields[task.FieldMessage] = struct{}{}
}

// MessageCleared returns if the "message" field was cleared in this mutation.
func (m *TaskMutation) MessageCleared() bool {
	_, ok := m.clearedFields[task.FieldMessage]
	return ok
}

// ResetMessage resets all changes to the "message" field.
func (m *TaskMutation) ResetMessage() {
	m.message = nil
	delete(m.clearedFields, task.FieldMessage)
}

// SetState sets the "state" field.
func (m *TaskMutation) SetState(t task.State) {
	m.state = &t
}

// State returns the value of the "state" field in the mutation.
func (m *TaskMutation) State() (r task.State, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldState(ctx context.Context) (v *task.State, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *TaskMutation) ClearState() {
	m.state = nil
	m.clearedFields[task.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *TaskMutation) StateCleared() bool {
	_, ok := m.clearedFields[task.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *TaskMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, task.FieldState)
}

// SetPreviousState sets the "previous_state" field.
func (m *TaskMutation) SetPreviousState(ts task.PreviousState) {
	m.previous_state = &ts
}

// PreviousState returns the value of the "previous_state" field in the mutation.
func (m *TaskMutation) PreviousState() (r task.PreviousState, exists bool) {
	v := m.previous_state
	if v == nil {
		return
	}
	return *v, true
}

// OldPreviousState returns the old "previous_state" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldPreviousState(ctx context.Context) (v *task.PreviousState, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreviousState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreviousState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreviousState: %w", err)
	}
	return oldValue.PreviousState, nil
}

// ClearPreviousState clears the value of the "previous_state" field.
func (m *TaskMutation) ClearPreviousState() {
	m.previous_state = nil
	m.clearedFields[task.FieldPreviousState] = struct{}{}
}

// PreviousStateCleared returns if the "previous_state" field was cleared in this mutation.
func (m *TaskMutation) PreviousStateCleared() bool {
	_, ok := m.clearedFields[task.FieldPreviousState]
	return ok
}

// ResetPreviousState resets all changes to the "previous_state" field.
func (m *TaskMutation) ResetPreviousState() {
	m.previous_state = nil
	delete(m.clearedFields, task.FieldPreviousState)
}

// SetStartTime sets the "start_time" field.
func (m *TaskMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *TaskMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldStartTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ClearStartTime clears the value of the "start_time" field.
func (m *TaskMutation) ClearStartTime() {
	m.start_time = nil
	m.clearedFields[task.FieldStartTime] = struct{}{}
}

// StartTimeCleared returns if the "start_time" field was cleared in this mutation.
func (m *TaskMutation) StartTimeCleared() bool {
	_, ok := m.clearedFields[task.FieldStartTime]
	return ok
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *TaskMutation) ResetStartTime() {
	m.start_time = nil
	delete(m.clearedFields, task.FieldStartTime)
}

// SetEndTime sets the "end_time" field.
func (m *TaskMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *TaskMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldEndTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "end_time" field.
func (m *TaskMutation) ClearEndTime() {
	m.end_time = nil
	m.clearedFields[task.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *TaskMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[task.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *TaskMutation) ResetEndTime() {
	m.end_time = nil
	delete(m.clearedFields, task.FieldEndTime)
}

// SetName sets the "name" field.
func (m *TaskMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TaskMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TaskMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *TaskMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *TaskMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDesc(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ClearDesc clears the value of the "desc" field.
func (m *TaskMutation) ClearDesc() {
	m.desc = nil
	m.clearedFields[task.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *TaskMutation) DescCleared() bool {
	_, ok := m.clearedFields[task.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *TaskMutation) ResetDesc() {
	m.desc = nil
	delete(m.clearedFields, task.FieldDesc)
}

// SetKind sets the "kind" field.
func (m *TaskMutation) SetKind(s string) {
	m.kind = &s
}

// Kind returns the value of the "kind" field in the mutation.
func (m *TaskMutation) Kind() (r string, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldKind(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ClearKind clears the value of the "kind" field.
func (m *TaskMutation) ClearKind() {
	m.kind = nil
	m.clearedFields[task.FieldKind] = struct{}{}
}

// KindCleared returns if the "kind" field was cleared in this mutation.
func (m *TaskMutation) KindCleared() bool {
	_, ok := m.clearedFields[task.FieldKind]
	return ok
}

// ResetKind resets all changes to the "kind" field.
func (m *TaskMutation) ResetKind() {
	m.kind = nil
	delete(m.clearedFields, task.FieldKind)
}

// SetNode sets the "node" field.
func (m *TaskMutation) SetNode(s string) {
	m.node = &s
}

// Node returns the value of the "node" field in the mutation.
func (m *TaskMutation) Node() (r string, exists bool) {
	v := m.node
	if v == nil {
		return
	}
	return *v, true
}

// OldNode returns the old "node" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldNode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNode: %w", err)
	}
	return oldValue.Node, nil
}

// ClearNode clears the value of the "node" field.
func (m *TaskMutation) ClearNode() {
	m.node = nil
	m.clearedFields[task.FieldNode] = struct{}{}
}

// NodeCleared returns if the "node" field was cleared in this mutation.
func (m *TaskMutation) NodeCleared() bool {
	_, ok := m.clearedFields[task.FieldNode]
	return ok
}

// ResetNode resets all changes to the "node" field.
func (m *TaskMutation) ResetNode() {
	m.node = nil
	delete(m.clearedFields, task.FieldNode)
}

// SetTimeout sets the "timeout" field.
func (m *TaskMutation) SetTimeout(i int64) {
	m.timeout = &i
	m.addtimeout = nil
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *TaskMutation) Timeout() (r int64, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldTimeout(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// AddTimeout adds i to the "timeout" field.
func (m *TaskMutation) AddTimeout(i int64) {
	if m.addtimeout != nil {
		*m.addtimeout += i
	} else {
		m.addtimeout = &i
	}
}

// AddedTimeout returns the value that was added to the "timeout" field in this mutation.
func (m *TaskMutation) AddedTimeout() (r int64, exists bool) {
	v := m.addtimeout
	if v == nil {
		return
	}
	return *v, true
}

// ClearTimeout clears the value of the "timeout" field.
func (m *TaskMutation) ClearTimeout() {
	m.timeout = nil
	m.addtimeout = nil
	m.clearedFields[task.FieldTimeout] = struct{}{}
}

// TimeoutCleared returns if the "timeout" field was cleared in this mutation.
func (m *TaskMutation) TimeoutCleared() bool {
	_, ok := m.clearedFields[task.FieldTimeout]
	return ok
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *TaskMutation) ResetTimeout() {
	m.timeout = nil
	m.addtimeout = nil
	delete(m.clearedFields, task.FieldTimeout)
}

// SetRetryPolicy sets the "retry_policy" field.
func (m *TaskMutation) SetRetryPolicy(sp *schema.RetryPolicy) {
	m.retry_policy = &sp
}

// RetryPolicy returns the value of the "retry_policy" field in the mutation.
func (m *TaskMutation) RetryPolicy() (r *schema.RetryPolicy, exists bool) {
	v := m.retry_policy
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryPolicy returns the old "retry_policy" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldRetryPolicy(ctx context.Context) (v *schema.RetryPolicy, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryPolicy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryPolicy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryPolicy: %w", err)
	}
	return oldValue.RetryPolicy, nil
}

// ClearRetryPolicy clears the value of the "retry_policy" field.
func (m *TaskMutation) ClearRetryPolicy() {
	m.retry_policy = nil
	m.clearedFields[task.FieldRetryPolicy] = struct{}{}
}

// RetryPolicyCleared returns if the "retry_policy" field was cleared in this mutation.
func (m *TaskMutation) RetryPolicyCleared() bool {
	_, ok := m.clearedFields[task.FieldRetryPolicy]
	return ok
}

// ResetRetryPolicy resets all changes to the "retry_policy" field.
func (m *TaskMutation) ResetRetryPolicy() {
	m.retry_policy = nil
	delete(m.clearedFields, task.FieldRetryPolicy)
}

// SetIsTpl sets the "is_tpl" field.
func (m *TaskMutation) SetIsTpl(b bool) {
	m.is_tpl = &b
}

// IsTpl returns the value of the "is_tpl" field in the mutation.
func (m *TaskMutation) IsTpl() (r bool, exists bool) {
	v := m.is_tpl
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTpl returns the old "is_tpl" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldIsTpl(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTpl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTpl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTpl: %w", err)
	}
	return oldValue.IsTpl, nil
}

// ClearIsTpl clears the value of the "is_tpl" field.
func (m *TaskMutation) ClearIsTpl() {
	m.is_tpl = nil
	m.clearedFields[task.FieldIsTpl] = struct{}{}
}

// IsTplCleared returns if the "is_tpl" field was cleared in this mutation.
func (m *TaskMutation) IsTplCleared() bool {
	_, ok := m.clearedFields[task.FieldIsTpl]
	return ok
}

// ResetIsTpl resets all changes to the "is_tpl" field.
func (m *TaskMutation) ResetIsTpl() {
	m.is_tpl = nil
	delete(m.clearedFields, task.FieldIsTpl)
}

// AddStepIDs adds the "steps" edge to the Step entity by ids.
func (m *TaskMutation) AddStepIDs(ids ...uint64) {
	if m.steps == nil {
		m.steps = make(map[uint64]struct{})
	}
	for i := range ids {
		m.steps[ids[i]] = struct{}{}
	}
}

// ClearSteps clears the "steps" edge to the Step entity.
func (m *TaskMutation) ClearSteps() {
	m.clearedsteps = true
}

// StepsCleared reports if the "steps" edge to the Step entity was cleared.
func (m *TaskMutation) StepsCleared() bool {
	return m.clearedsteps
}

// RemoveStepIDs removes the "steps" edge to the Step entity by IDs.
func (m *TaskMutation) RemoveStepIDs(ids ...uint64) {
	if m.removedsteps == nil {
		m.removedsteps = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.steps, ids[i])
		m.removedsteps[ids[i]] = struct{}{}
	}
}

// RemovedSteps returns the removed IDs of the "steps" edge to the Step entity.
func (m *TaskMutation) RemovedStepsIDs() (ids []uint64) {
	for id := range m.removedsteps {
		ids = append(ids, id)
	}
	return
}

// StepsIDs returns the "steps" edge IDs in the mutation.
func (m *TaskMutation) StepsIDs() (ids []uint64) {
	for id := range m.steps {
		ids = append(ids, id)
	}
	return
}

// ResetSteps resets all changes to the "steps" edge.
func (m *TaskMutation) ResetSteps() {
	m.steps = nil
	m.clearedsteps = false
	m.removedsteps = nil
}

// AddParamIDs adds the "params" edge to the Param entity by ids.
func (m *TaskMutation) AddParamIDs(ids ...uint64) {
	if m.params == nil {
		m.params = make(map[uint64]struct{})
	}
	for i := range ids {
		m.params[ids[i]] = struct{}{}
	}
}

// ClearParams clears the "params" edge to the Param entity.
func (m *TaskMutation) ClearParams() {
	m.clearedparams = true
}

// ParamsCleared reports if the "params" edge to the Param entity was cleared.
func (m *TaskMutation) ParamsCleared() bool {
	return m.clearedparams
}

// RemoveParamIDs removes the "params" edge to the Param entity by IDs.
func (m *TaskMutation) RemoveParamIDs(ids ...uint64) {
	if m.removedparams == nil {
		m.removedparams = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.params, ids[i])
		m.removedparams[ids[i]] = struct{}{}
	}
}

// RemovedParams returns the removed IDs of the "params" edge to the Param entity.
func (m *TaskMutation) RemovedParamsIDs() (ids []uint64) {
	for id := range m.removedparams {
		ids = append(ids, id)
	}
	return
}

// ParamsIDs returns the "params" edge IDs in the mutation.
func (m *TaskMutation) ParamsIDs() (ids []uint64) {
	for id := range m.params {
		ids = append(ids, id)
	}
	return
}

// ResetParams resets all changes to the "params" edge.
func (m *TaskMutation) ResetParams() {
	m.params = nil
	m.clearedparams = false
	m.removedparams = nil
}

// AddTaskStepIDs adds the "task_steps" edge to the TaskStep entity by ids.
func (m *TaskMutation) AddTaskStepIDs(ids ...uint64) {
	if m.task_steps == nil {
		m.task_steps = make(map[uint64]struct{})
	}
	for i := range ids {
		m.task_steps[ids[i]] = struct{}{}
	}
}

// ClearTaskSteps clears the "task_steps" edge to the TaskStep entity.
func (m *TaskMutation) ClearTaskSteps() {
	m.clearedtask_steps = true
}

// TaskStepsCleared reports if the "task_steps" edge to the TaskStep entity was cleared.
func (m *TaskMutation) TaskStepsCleared() bool {
	return m.clearedtask_steps
}

// RemoveTaskStepIDs removes the "task_steps" edge to the TaskStep entity by IDs.
func (m *TaskMutation) RemoveTaskStepIDs(ids ...uint64) {
	if m.removedtask_steps == nil {
		m.removedtask_steps = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.task_steps, ids[i])
		m.removedtask_steps[ids[i]] = struct{}{}
	}
}

// RemovedTaskSteps returns the removed IDs of the "task_steps" edge to the TaskStep entity.
func (m *TaskMutation) RemovedTaskStepsIDs() (ids []uint64) {
	for id := range m.removedtask_steps {
		ids = append(ids, id)
	}
	return
}

// TaskStepsIDs returns the "task_steps" edge IDs in the mutation.
func (m *TaskMutation) TaskStepsIDs() (ids []uint64) {
	for id := range m.task_steps {
		ids = append(ids, id)
	}
	return
}

// ResetTaskSteps resets all changes to the "task_steps" edge.
func (m *TaskMutation) ResetTaskSteps() {
	m.task_steps = nil
	m.clearedtask_steps = false
	m.removedtask_steps = nil
}

// AddTaskParamIDs adds the "task_params" edge to the TaskParam entity by ids.
func (m *TaskMutation) AddTaskParamIDs(ids ...uint64) {
	if m.task_params == nil {
		m.task_params = make(map[uint64]struct{})
	}
	for i := range ids {
		m.task_params[ids[i]] = struct{}{}
	}
}

// ClearTaskParams clears the "task_params" edge to the TaskParam entity.
func (m *TaskMutation) ClearTaskParams() {
	m.clearedtask_params = true
}

// TaskParamsCleared reports if the "task_params" edge to the TaskParam entity was cleared.
func (m *TaskMutation) TaskParamsCleared() bool {
	return m.clearedtask_params
}

// RemoveTaskParamIDs removes the "task_params" edge to the TaskParam entity by IDs.
func (m *TaskMutation) RemoveTaskParamIDs(ids ...uint64) {
	if m.removedtask_params == nil {
		m.removedtask_params = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.task_params, ids[i])
		m.removedtask_params[ids[i]] = struct{}{}
	}
}

// RemovedTaskParams returns the removed IDs of the "task_params" edge to the TaskParam entity.
func (m *TaskMutation) RemovedTaskParamsIDs() (ids []uint64) {
	for id := range m.removedtask_params {
		ids = append(ids, id)
	}
	return
}

// TaskParamsIDs returns the "task_params" edge IDs in the mutation.
func (m *TaskMutation) TaskParamsIDs() (ids []uint64) {
	for id := range m.task_params {
		ids = append(ids, id)
	}
	return
}

// ResetTaskParams resets all changes to the "task_params" edge.
func (m *TaskMutation) ResetTaskParams() {
	m.task_params = nil
	m.clearedtask_params = false
	m.removedtask_params = nil
}

// Where appends a list predicates to the TaskMutation builder.
func (m *TaskMutation) Where(ps ...predicate.Task) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Task, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Task).
func (m *TaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, task.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, task.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, task.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, task.FieldUpdatedBy)
	}
	if m.disabled != nil {
		fields = append(fields, task.FieldDisabled)
	}
	if m.message != nil {
		fields = append(fields, task.FieldMessage)
	}
	if m.state != nil {
		fields = append(fields, task.FieldState)
	}
	if m.previous_state != nil {
		fields = append(fields, task.FieldPreviousState)
	}
	if m.start_time != nil {
		fields = append(fields, task.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, task.FieldEndTime)
	}
	if m.name != nil {
		fields = append(fields, task.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, task.FieldDesc)
	}
	if m.kind != nil {
		fields = append(fields, task.FieldKind)
	}
	if m.node != nil {
		fields = append(fields, task.FieldNode)
	}
	if m.timeout != nil {
		fields = append(fields, task.FieldTimeout)
	}
	if m.retry_policy != nil {
		fields = append(fields, task.FieldRetryPolicy)
	}
	if m.is_tpl != nil {
		fields = append(fields, task.FieldIsTpl)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case task.FieldCreatedAt:
		return m.CreatedAt()
	case task.FieldUpdatedAt:
		return m.UpdatedAt()
	case task.FieldCreatedBy:
		return m.CreatedBy()
	case task.FieldUpdatedBy:
		return m.UpdatedBy()
	case task.FieldDisabled:
		return m.Disabled()
	case task.FieldMessage:
		return m.Message()
	case task.FieldState:
		return m.State()
	case task.FieldPreviousState:
		return m.PreviousState()
	case task.FieldStartTime:
		return m.StartTime()
	case task.FieldEndTime:
		return m.EndTime()
	case task.FieldName:
		return m.Name()
	case task.FieldDesc:
		return m.Desc()
	case task.FieldKind:
		return m.Kind()
	case task.FieldNode:
		return m.Node()
	case task.FieldTimeout:
		return m.Timeout()
	case task.FieldRetryPolicy:
		return m.RetryPolicy()
	case task.FieldIsTpl:
		return m.IsTpl()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case task.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case task.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case task.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case task.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case task.FieldDisabled:
		return m.OldDisabled(ctx)
	case task.FieldMessage:
		return m.OldMessage(ctx)
	case task.FieldState:
		return m.OldState(ctx)
	case task.FieldPreviousState:
		return m.OldPreviousState(ctx)
	case task.FieldStartTime:
		return m.OldStartTime(ctx)
	case task.FieldEndTime:
		return m.OldEndTime(ctx)
	case task.FieldName:
		return m.OldName(ctx)
	case task.FieldDesc:
		return m.OldDesc(ctx)
	case task.FieldKind:
		return m.OldKind(ctx)
	case task.FieldNode:
		return m.OldNode(ctx)
	case task.FieldTimeout:
		return m.OldTimeout(ctx)
	case task.FieldRetryPolicy:
		return m.OldRetryPolicy(ctx)
	case task.FieldIsTpl:
		return m.OldIsTpl(ctx)
	}
	return nil, fmt.Errorf("unknown Task field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case task.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case task.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case task.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case task.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case task.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case task.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case task.FieldState:
		v, ok := value.(task.State)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case task.FieldPreviousState:
		v, ok := value.(task.PreviousState)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreviousState(v)
		return nil
	case task.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case task.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case task.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case task.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case task.FieldKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case task.FieldNode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNode(v)
		return nil
	case task.FieldTimeout:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case task.FieldRetryPolicy:
		v, ok := value.(*schema.RetryPolicy)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryPolicy(v)
		return nil
	case task.FieldIsTpl:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTpl(v)
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskMutation) AddedFields() []string {
	var fields []string
	if m.addtimeout != nil {
		fields = append(fields, task.FieldTimeout)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case task.FieldTimeout:
		return m.AddedTimeout()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case task.FieldTimeout:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeout(v)
		return nil
	}
	return fmt.Errorf("unknown Task numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(task.FieldCreatedAt) {
		fields = append(fields, task.FieldCreatedAt)
	}
	if m.FieldCleared(task.FieldUpdatedAt) {
		fields = append(fields, task.FieldUpdatedAt)
	}
	if m.FieldCleared(task.FieldCreatedBy) {
		fields = append(fields, task.FieldCreatedBy)
	}
	if m.FieldCleared(task.FieldUpdatedBy) {
		fields = append(fields, task.FieldUpdatedBy)
	}
	if m.FieldCleared(task.FieldDisabled) {
		fields = append(fields, task.FieldDisabled)
	}
	if m.FieldCleared(task.FieldMessage) {
		fields = append(fields, task.FieldMessage)
	}
	if m.FieldCleared(task.FieldState) {
		fields = append(fields, task.FieldState)
	}
	if m.FieldCleared(task.FieldPreviousState) {
		fields = append(fields, task.FieldPreviousState)
	}
	if m.FieldCleared(task.FieldStartTime) {
		fields = append(fields, task.FieldStartTime)
	}
	if m.FieldCleared(task.FieldEndTime) {
		fields = append(fields, task.FieldEndTime)
	}
	if m.FieldCleared(task.FieldDesc) {
		fields = append(fields, task.FieldDesc)
	}
	if m.FieldCleared(task.FieldKind) {
		fields = append(fields, task.FieldKind)
	}
	if m.FieldCleared(task.FieldNode) {
		fields = append(fields, task.FieldNode)
	}
	if m.FieldCleared(task.FieldTimeout) {
		fields = append(fields, task.FieldTimeout)
	}
	if m.FieldCleared(task.FieldRetryPolicy) {
		fields = append(fields, task.FieldRetryPolicy)
	}
	if m.FieldCleared(task.FieldIsTpl) {
		fields = append(fields, task.FieldIsTpl)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskMutation) ClearField(name string) error {
	switch name {
	case task.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case task.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case task.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case task.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case task.FieldDisabled:
		m.ClearDisabled()
		return nil
	case task.FieldMessage:
		m.ClearMessage()
		return nil
	case task.FieldState:
		m.ClearState()
		return nil
	case task.FieldPreviousState:
		m.ClearPreviousState()
		return nil
	case task.FieldStartTime:
		m.ClearStartTime()
		return nil
	case task.FieldEndTime:
		m.ClearEndTime()
		return nil
	case task.FieldDesc:
		m.ClearDesc()
		return nil
	case task.FieldKind:
		m.ClearKind()
		return nil
	case task.FieldNode:
		m.ClearNode()
		return nil
	case task.FieldTimeout:
		m.ClearTimeout()
		return nil
	case task.FieldRetryPolicy:
		m.ClearRetryPolicy()
		return nil
	case task.FieldIsTpl:
		m.ClearIsTpl()
		return nil
	}
	return fmt.Errorf("unknown Task nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskMutation) ResetField(name string) error {
	switch name {
	case task.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case task.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case task.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case task.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case task.FieldDisabled:
		m.ResetDisabled()
		return nil
	case task.FieldMessage:
		m.ResetMessage()
		return nil
	case task.FieldState:
		m.ResetState()
		return nil
	case task.FieldPreviousState:
		m.ResetPreviousState()
		return nil
	case task.FieldStartTime:
		m.ResetStartTime()
		return nil
	case task.FieldEndTime:
		m.ResetEndTime()
		return nil
	case task.FieldName:
		m.ResetName()
		return nil
	case task.FieldDesc:
		m.ResetDesc()
		return nil
	case task.FieldKind:
		m.ResetKind()
		return nil
	case task.FieldNode:
		m.ResetNode()
		return nil
	case task.FieldTimeout:
		m.ResetTimeout()
		return nil
	case task.FieldRetryPolicy:
		m.ResetRetryPolicy()
		return nil
	case task.FieldIsTpl:
		m.ResetIsTpl()
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.steps != nil {
		edges = append(edges, task.EdgeSteps)
	}
	if m.params != nil {
		edges = append(edges, task.EdgeParams)
	}
	if m.task_steps != nil {
		edges = append(edges, task.EdgeTaskSteps)
	}
	if m.task_params != nil {
		edges = append(edges, task.EdgeTaskParams)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeSteps:
		ids := make([]ent.Value, 0, len(m.steps))
		for id := range m.steps {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeParams:
		ids := make([]ent.Value, 0, len(m.params))
		for id := range m.params {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeTaskSteps:
		ids := make([]ent.Value, 0, len(m.task_steps))
		for id := range m.task_steps {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeTaskParams:
		ids := make([]ent.Value, 0, len(m.task_params))
		for id := range m.task_params {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedsteps != nil {
		edges = append(edges, task.EdgeSteps)
	}
	if m.removedparams != nil {
		edges = append(edges, task.EdgeParams)
	}
	if m.removedtask_steps != nil {
		edges = append(edges, task.EdgeTaskSteps)
	}
	if m.removedtask_params != nil {
		edges = append(edges, task.EdgeTaskParams)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeSteps:
		ids := make([]ent.Value, 0, len(m.removedsteps))
		for id := range m.removedsteps {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeParams:
		ids := make([]ent.Value, 0, len(m.removedparams))
		for id := range m.removedparams {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeTaskSteps:
		ids := make([]ent.Value, 0, len(m.removedtask_steps))
		for id := range m.removedtask_steps {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeTaskParams:
		ids := make([]ent.Value, 0, len(m.removedtask_params))
		for id := range m.removedtask_params {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedsteps {
		edges = append(edges, task.EdgeSteps)
	}
	if m.clearedparams {
		edges = append(edges, task.EdgeParams)
	}
	if m.clearedtask_steps {
		edges = append(edges, task.EdgeTaskSteps)
	}
	if m.clearedtask_params {
		edges = append(edges, task.EdgeTaskParams)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskMutation) EdgeCleared(name string) bool {
	switch name {
	case task.EdgeSteps:
		return m.clearedsteps
	case task.EdgeParams:
		return m.clearedparams
	case task.EdgeTaskSteps:
		return m.clearedtask_steps
	case task.EdgeTaskParams:
		return m.clearedtask_params
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Task unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskMutation) ResetEdge(name string) error {
	switch name {
	case task.EdgeSteps:
		m.ResetSteps()
		return nil
	case task.EdgeParams:
		m.ResetParams()
		return nil
	case task.EdgeTaskSteps:
		m.ResetTaskSteps()
		return nil
	case task.EdgeTaskParams:
		m.ResetTaskParams()
		return nil
	}
	return fmt.Errorf("unknown Task edge %s", name)
}

// TaskParamMutation represents an operation that mutates the TaskParam nodes in the graph.
type TaskParamMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	created_by    *string
	updated_by    *string
	clearedFields map[string]struct{}
	task          *uint64
	clearedtask   bool
	param         *uint64
	clearedparam  bool
	done          bool
	oldValue      func(context.Context) (*TaskParam, error)
	predicates    []predicate.TaskParam
}

var _ ent.Mutation = (*TaskParamMutation)(nil)

// taskparamOption allows management of the mutation configuration using functional options.
type taskparamOption func(*TaskParamMutation)

// newTaskParamMutation creates new mutation for the TaskParam entity.
func newTaskParamMutation(c config, op Op, opts ...taskparamOption) *TaskParamMutation {
	m := &TaskParamMutation{
		config:        c,
		op:            op,
		typ:           TypeTaskParam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskParamID sets the ID field of the mutation.
func withTaskParamID(id uint64) taskparamOption {
	return func(m *TaskParamMutation) {
		var (
			err   error
			once  sync.Once
			value *TaskParam
		)
		m.oldValue = func(ctx context.Context) (*TaskParam, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TaskParam.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTaskParam sets the old TaskParam of the mutation.
func withTaskParam(node *TaskParam) taskparamOption {
	return func(m *TaskParamMutation) {
		m.oldValue = func(context.Context) (*TaskParam, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskParamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskParamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entv1: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TaskParam entities.
func (m *TaskParamMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskParamMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskParamMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TaskParam.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskParamMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskParamMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TaskParam entity.
// If the TaskParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskParamMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TaskParamMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[taskparam.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TaskParamMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[taskparam.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskParamMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, taskparam.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskParamMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskParamMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TaskParam entity.
// If the TaskParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskParamMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TaskParamMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[taskparam.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TaskParamMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[taskparam.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskParamMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, taskparam.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *TaskParamMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TaskParamMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the TaskParam entity.
// If the TaskParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskParamMutation) OldCreatedBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *TaskParamMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[taskparam.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *TaskParamMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[taskparam.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TaskParamMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, taskparam.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TaskParamMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TaskParamMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the TaskParam entity.
// If the TaskParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskParamMutation) OldUpdatedBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *TaskParamMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[taskparam.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *TaskParamMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[taskparam.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TaskParamMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, taskparam.FieldUpdatedBy)
}

// SetTaskID sets the "task_id" field.
func (m *TaskParamMutation) SetTaskID(u uint64) {
	m.task = &u
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *TaskParamMutation) TaskID() (r uint64, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the TaskParam entity.
// If the TaskParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskParamMutation) OldTaskID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *TaskParamMutation) ResetTaskID() {
	m.task = nil
}

// SetParamID sets the "param_id" field.
func (m *TaskParamMutation) SetParamID(u uint64) {
	m.param = &u
}

// ParamID returns the value of the "param_id" field in the mutation.
func (m *TaskParamMutation) ParamID() (r uint64, exists bool) {
	v := m.param
	if v == nil {
		return
	}
	return *v, true
}

// OldParamID returns the old "param_id" field's value of the TaskParam entity.
// If the TaskParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskParamMutation) OldParamID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParamID: %w", err)
	}
	return oldValue.ParamID, nil
}

// ResetParamID resets all changes to the "param_id" field.
func (m *TaskParamMutation) ResetParamID() {
	m.param = nil
}

// ClearTask clears the "task" edge to the Task entity.
func (m *TaskParamMutation) ClearTask() {
	m.clearedtask = true
	m.clearedFields[taskparam.FieldTaskID] = struct{}{}
}

// TaskCleared reports if the "task" edge to the Task entity was cleared.
func (m *TaskParamMutation) TaskCleared() bool {
	return m.clearedtask
}

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *TaskParamMutation) TaskIDs() (ids []uint64) {
	if id := m.task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *TaskParamMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
}

// ClearParam clears the "param" edge to the Param entity.
func (m *TaskParamMutation) ClearParam() {
	m.clearedparam = true
	m.clearedFields[taskparam.FieldParamID] = struct{}{}
}

// ParamCleared reports if the "param" edge to the Param entity was cleared.
func (m *TaskParamMutation) ParamCleared() bool {
	return m.clearedparam
}

// ParamIDs returns the "param" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParamID instead. It exists only for internal usage by the builders.
func (m *TaskParamMutation) ParamIDs() (ids []uint64) {
	if id := m.param; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParam resets all changes to the "param" edge.
func (m *TaskParamMutation) ResetParam() {
	m.param = nil
	m.clearedparam = false
}

// Where appends a list predicates to the TaskParamMutation builder.
func (m *TaskParamMutation) Where(ps ...predicate.TaskParam) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskParamMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskParamMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TaskParam, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskParamMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskParamMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TaskParam).
func (m *TaskParamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskParamMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, taskparam.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, taskparam.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, taskparam.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, taskparam.FieldUpdatedBy)
	}
	if m.task != nil {
		fields = append(fields, taskparam.FieldTaskID)
	}
	if m.param != nil {
		fields = append(fields, taskparam.FieldParamID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskParamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case taskparam.FieldCreatedAt:
		return m.CreatedAt()
	case taskparam.FieldUpdatedAt:
		return m.UpdatedAt()
	case taskparam.FieldCreatedBy:
		return m.CreatedBy()
	case taskparam.FieldUpdatedBy:
		return m.UpdatedBy()
	case taskparam.FieldTaskID:
		return m.TaskID()
	case taskparam.FieldParamID:
		return m.ParamID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskParamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case taskparam.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case taskparam.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case taskparam.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case taskparam.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case taskparam.FieldTaskID:
		return m.OldTaskID(ctx)
	case taskparam.FieldParamID:
		return m.OldParamID(ctx)
	}
	return nil, fmt.Errorf("unknown TaskParam field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskParamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case taskparam.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case taskparam.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case taskparam.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case taskparam.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case taskparam.FieldTaskID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case taskparam.FieldParamID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParamID(v)
		return nil
	}
	return fmt.Errorf("unknown TaskParam field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskParamMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskParamMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskParamMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TaskParam numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskParamMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(taskparam.FieldCreatedAt) {
		fields = append(fields, taskparam.FieldCreatedAt)
	}
	if m.FieldCleared(taskparam.FieldUpdatedAt) {
		fields = append(fields, taskparam.FieldUpdatedAt)
	}
	if m.FieldCleared(taskparam.FieldCreatedBy) {
		fields = append(fields, taskparam.FieldCreatedBy)
	}
	if m.FieldCleared(taskparam.FieldUpdatedBy) {
		fields = append(fields, taskparam.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskParamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskParamMutation) ClearField(name string) error {
	switch name {
	case taskparam.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case taskparam.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case taskparam.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case taskparam.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown TaskParam nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskParamMutation) ResetField(name string) error {
	switch name {
	case taskparam.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case taskparam.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case taskparam.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case taskparam.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case taskparam.FieldTaskID:
		m.ResetTaskID()
		return nil
	case taskparam.FieldParamID:
		m.ResetParamID()
		return nil
	}
	return fmt.Errorf("unknown TaskParam field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskParamMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.task != nil {
		edges = append(edges, taskparam.EdgeTask)
	}
	if m.param != nil {
		edges = append(edges, taskparam.EdgeParam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskParamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case taskparam.EdgeTask:
		if id := m.task; id != nil {
			return []ent.Value{*id}
		}
	case taskparam.EdgeParam:
		if id := m.param; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskParamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskParamMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskParamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtask {
		edges = append(edges, taskparam.EdgeTask)
	}
	if m.clearedparam {
		edges = append(edges, taskparam.EdgeParam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskParamMutation) EdgeCleared(name string) bool {
	switch name {
	case taskparam.EdgeTask:
		return m.clearedtask
	case taskparam.EdgeParam:
		return m.clearedparam
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskParamMutation) ClearEdge(name string) error {
	switch name {
	case taskparam.EdgeTask:
		m.ClearTask()
		return nil
	case taskparam.EdgeParam:
		m.ClearParam()
		return nil
	}
	return fmt.Errorf("unknown TaskParam unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskParamMutation) ResetEdge(name string) error {
	switch name {
	case taskparam.EdgeTask:
		m.ResetTask()
		return nil
	case taskparam.EdgeParam:
		m.ResetParam()
		return nil
	}
	return fmt.Errorf("unknown TaskParam edge %s", name)
}

// TaskStepMutation represents an operation that mutates the TaskStep nodes in the graph.
type TaskStepMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	created_at     *time.Time
	updated_at     *time.Time
	created_by     *string
	updated_by     *string
	disabled       *bool
	message        *string
	state          *taskstep.State
	previous_state *taskstep.PreviousState
	start_time     *time.Time
	end_time       *time.Time
	seq_no         *int64
	addseq_no      *int64
	code           *int64
	addcode        *int64
	clearedFields  map[string]struct{}
	task           *uint64
	clearedtask    bool
	step           *uint64
	clearedstep    bool
	outputs        map[uint64]struct{}
	removedoutputs map[uint64]struct{}
	clearedoutputs bool
	done           bool
	oldValue       func(context.Context) (*TaskStep, error)
	predicates     []predicate.TaskStep
}

var _ ent.Mutation = (*TaskStepMutation)(nil)

// taskstepOption allows management of the mutation configuration using functional options.
type taskstepOption func(*TaskStepMutation)

// newTaskStepMutation creates new mutation for the TaskStep entity.
func newTaskStepMutation(c config, op Op, opts ...taskstepOption) *TaskStepMutation {
	m := &TaskStepMutation{
		config:        c,
		op:            op,
		typ:           TypeTaskStep,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskStepID sets the ID field of the mutation.
func withTaskStepID(id uint64) taskstepOption {
	return func(m *TaskStepMutation) {
		var (
			err   error
			once  sync.Once
			value *TaskStep
		)
		m.oldValue = func(ctx context.Context) (*TaskStep, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TaskStep.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTaskStep sets the old TaskStep of the mutation.
func withTaskStep(node *TaskStep) taskstepOption {
	return func(m *TaskStepMutation) {
		m.oldValue = func(context.Context) (*TaskStep, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskStepMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskStepMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entv1: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TaskStep entities.
func (m *TaskStepMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskStepMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskStepMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TaskStep.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskStepMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskStepMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TaskStep entity.
// If the TaskStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskStepMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TaskStepMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[taskstep.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TaskStepMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[taskstep.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskStepMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, taskstep.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskStepMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskStepMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TaskStep entity.
// If the TaskStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskStepMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TaskStepMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[taskstep.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TaskStepMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[taskstep.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskStepMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, taskstep.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *TaskStepMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TaskStepMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the TaskStep entity.
// If the TaskStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskStepMutation) OldCreatedBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *TaskStepMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[taskstep.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *TaskStepMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[taskstep.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TaskStepMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, taskstep.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TaskStepMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TaskStepMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the TaskStep entity.
// If the TaskStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskStepMutation) OldUpdatedBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *TaskStepMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[taskstep.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *TaskStepMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[taskstep.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TaskStepMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, taskstep.FieldUpdatedBy)
}

// SetDisabled sets the "disabled" field.
func (m *TaskStepMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *TaskStepMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the TaskStep entity.
// If the TaskStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskStepMutation) OldDisabled(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ClearDisabled clears the value of the "disabled" field.
func (m *TaskStepMutation) ClearDisabled() {
	m.disabled = nil
	m.clearedFields[taskstep.FieldDisabled] = struct{}{}
}

// DisabledCleared returns if the "disabled" field was cleared in this mutation.
func (m *TaskStepMutation) DisabledCleared() bool {
	_, ok := m.clearedFields[taskstep.FieldDisabled]
	return ok
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *TaskStepMutation) ResetDisabled() {
	m.disabled = nil
	delete(m.clearedFields, taskstep.FieldDisabled)
}

// SetMessage sets the "message" field.
func (m *TaskStepMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *TaskStepMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the TaskStep entity.
// If the TaskStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskStepMutation) OldMessage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ClearMessage clears the value of the "message" field.
func (m *TaskStepMutation) ClearMessage() {
	m.message = nil
	m.clearedFields[taskstep.FieldMessage] = struct{}{}
}

// MessageCleared returns if the "message" field was cleared in this mutation.
func (m *TaskStepMutation) MessageCleared() bool {
	_, ok := m.clearedFields[taskstep.FieldMessage]
	return ok
}

// ResetMessage resets all changes to the "message" field.
func (m *TaskStepMutation) ResetMessage() {
	m.message = nil
	delete(m.clearedFields, taskstep.FieldMessage)
}

// SetState sets the "state" field.
func (m *TaskStepMutation) SetState(t taskstep.State) {
	m.state = &t
}

// State returns the value of the "state" field in the mutation.
func (m *TaskStepMutation) State() (r taskstep.State, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the TaskStep entity.
// If the TaskStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskStepMutation) OldState(ctx context.Context) (v *taskstep.State, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *TaskStepMutation) ClearState() {
	m.state = nil
	m.clearedFields[taskstep.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *TaskStepMutation) StateCleared() bool {
	_, ok := m.clearedFields[taskstep.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *TaskStepMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, taskstep.FieldState)
}

// SetPreviousState sets the "previous_state" field.
func (m *TaskStepMutation) SetPreviousState(ts taskstep.PreviousState) {
	m.previous_state = &ts
}

// PreviousState returns the value of the "previous_state" field in the mutation.
func (m *TaskStepMutation) PreviousState() (r taskstep.PreviousState, exists bool) {
	v := m.previous_state
	if v == nil {
		return
	}
	return *v, true
}

// OldPreviousState returns the old "previous_state" field's value of the TaskStep entity.
// If the TaskStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskStepMutation) OldPreviousState(ctx context.Context) (v *taskstep.PreviousState, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreviousState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreviousState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreviousState: %w", err)
	}
	return oldValue.PreviousState, nil
}

// ClearPreviousState clears the value of the "previous_state" field.
func (m *TaskStepMutation) ClearPreviousState() {
	m.previous_state = nil
	m.clearedFields[taskstep.FieldPreviousState] = struct{}{}
}

// PreviousStateCleared returns if the "previous_state" field was cleared in this mutation.
func (m *TaskStepMutation) PreviousStateCleared() bool {
	_, ok := m.clearedFields[taskstep.FieldPreviousState]
	return ok
}

// ResetPreviousState resets all changes to the "previous_state" field.
func (m *TaskStepMutation) ResetPreviousState() {
	m.previous_state = nil
	delete(m.clearedFields, taskstep.FieldPreviousState)
}

// SetStartTime sets the "start_time" field.
func (m *TaskStepMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *TaskStepMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the TaskStep entity.
// If the TaskStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskStepMutation) OldStartTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ClearStartTime clears the value of the "start_time" field.
func (m *TaskStepMutation) ClearStartTime() {
	m.start_time = nil
	m.clearedFields[taskstep.FieldStartTime] = struct{}{}
}

// StartTimeCleared returns if the "start_time" field was cleared in this mutation.
func (m *TaskStepMutation) StartTimeCleared() bool {
	_, ok := m.clearedFields[taskstep.FieldStartTime]
	return ok
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *TaskStepMutation) ResetStartTime() {
	m.start_time = nil
	delete(m.clearedFields, taskstep.FieldStartTime)
}

// SetEndTime sets the "end_time" field.
func (m *TaskStepMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *TaskStepMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the TaskStep entity.
// If the TaskStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskStepMutation) OldEndTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "end_time" field.
func (m *TaskStepMutation) ClearEndTime() {
	m.end_time = nil
	m.clearedFields[taskstep.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *TaskStepMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[taskstep.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *TaskStepMutation) ResetEndTime() {
	m.end_time = nil
	delete(m.clearedFields, taskstep.FieldEndTime)
}

// SetTaskID sets the "task_id" field.
func (m *TaskStepMutation) SetTaskID(u uint64) {
	m.task = &u
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *TaskStepMutation) TaskID() (r uint64, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the TaskStep entity.
// If the TaskStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskStepMutation) OldTaskID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *TaskStepMutation) ResetTaskID() {
	m.task = nil
}

// SetStepID sets the "step_id" field.
func (m *TaskStepMutation) SetStepID(u uint64) {
	m.step = &u
}

// StepID returns the value of the "step_id" field in the mutation.
func (m *TaskStepMutation) StepID() (r uint64, exists bool) {
	v := m.step
	if v == nil {
		return
	}
	return *v, true
}

// OldStepID returns the old "step_id" field's value of the TaskStep entity.
// If the TaskStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskStepMutation) OldStepID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStepID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStepID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStepID: %w", err)
	}
	return oldValue.StepID, nil
}

// ResetStepID resets all changes to the "step_id" field.
func (m *TaskStepMutation) ResetStepID() {
	m.step = nil
}

// SetSeqNo sets the "seq_no" field.
func (m *TaskStepMutation) SetSeqNo(i int64) {
	m.seq_no = &i
	m.addseq_no = nil
}

// SeqNo returns the value of the "seq_no" field in the mutation.
func (m *TaskStepMutation) SeqNo() (r int64, exists bool) {
	v := m.seq_no
	if v == nil {
		return
	}
	return *v, true
}

// OldSeqNo returns the old "seq_no" field's value of the TaskStep entity.
// If the TaskStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskStepMutation) OldSeqNo(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeqNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeqNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeqNo: %w", err)
	}
	return oldValue.SeqNo, nil
}

// AddSeqNo adds i to the "seq_no" field.
func (m *TaskStepMutation) AddSeqNo(i int64) {
	if m.addseq_no != nil {
		*m.addseq_no += i
	} else {
		m.addseq_no = &i
	}
}

// AddedSeqNo returns the value that was added to the "seq_no" field in this mutation.
func (m *TaskStepMutation) AddedSeqNo() (r int64, exists bool) {
	v := m.addseq_no
	if v == nil {
		return
	}
	return *v, true
}

// ClearSeqNo clears the value of the "seq_no" field.
func (m *TaskStepMutation) ClearSeqNo() {
	m.seq_no = nil
	m.addseq_no = nil
	m.clearedFields[taskstep.FieldSeqNo] = struct{}{}
}

// SeqNoCleared returns if the "seq_no" field was cleared in this mutation.
func (m *TaskStepMutation) SeqNoCleared() bool {
	_, ok := m.clearedFields[taskstep.FieldSeqNo]
	return ok
}

// ResetSeqNo resets all changes to the "seq_no" field.
func (m *TaskStepMutation) ResetSeqNo() {
	m.seq_no = nil
	m.addseq_no = nil
	delete(m.clearedFields, taskstep.FieldSeqNo)
}

// SetCode sets the "code" field.
func (m *TaskStepMutation) SetCode(i int64) {
	m.code = &i
	m.addcode = nil
}

// Code returns the value of the "code" field in the mutation.
func (m *TaskStepMutation) Code() (r int64, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the TaskStep entity.
// If the TaskStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskStepMutation) OldCode(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// AddCode adds i to the "code" field.
func (m *TaskStepMutation) AddCode(i int64) {
	if m.addcode != nil {
		*m.addcode += i
	} else {
		m.addcode = &i
	}
}

// AddedCode returns the value that was added to the "code" field in this mutation.
func (m *TaskStepMutation) AddedCode() (r int64, exists bool) {
	v := m.addcode
	if v == nil {
		return
	}
	return *v, true
}

// ClearCode clears the value of the "code" field.
func (m *TaskStepMutation) ClearCode() {
	m.code = nil
	m.addcode = nil
	m.clearedFields[taskstep.FieldCode] = struct{}{}
}

// CodeCleared returns if the "code" field was cleared in this mutation.
func (m *TaskStepMutation) CodeCleared() bool {
	_, ok := m.clearedFields[taskstep.FieldCode]
	return ok
}

// ResetCode resets all changes to the "code" field.
func (m *TaskStepMutation) ResetCode() {
	m.code = nil
	m.addcode = nil
	delete(m.clearedFields, taskstep.FieldCode)
}

// ClearTask clears the "task" edge to the Task entity.
func (m *TaskStepMutation) ClearTask() {
	m.clearedtask = true
	m.clearedFields[taskstep.FieldTaskID] = struct{}{}
}

// TaskCleared reports if the "task" edge to the Task entity was cleared.
func (m *TaskStepMutation) TaskCleared() bool {
	return m.clearedtask
}

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *TaskStepMutation) TaskIDs() (ids []uint64) {
	if id := m.task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *TaskStepMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
}

// ClearStep clears the "step" edge to the Step entity.
func (m *TaskStepMutation) ClearStep() {
	m.clearedstep = true
	m.clearedFields[taskstep.FieldStepID] = struct{}{}
}

// StepCleared reports if the "step" edge to the Step entity was cleared.
func (m *TaskStepMutation) StepCleared() bool {
	return m.clearedstep
}

// StepIDs returns the "step" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StepID instead. It exists only for internal usage by the builders.
func (m *TaskStepMutation) StepIDs() (ids []uint64) {
	if id := m.step; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStep resets all changes to the "step" edge.
func (m *TaskStepMutation) ResetStep() {
	m.step = nil
	m.clearedstep = false
}

// AddOutputIDs adds the "outputs" edge to the TaskStepOutput entity by ids.
func (m *TaskStepMutation) AddOutputIDs(ids ...uint64) {
	if m.outputs == nil {
		m.outputs = make(map[uint64]struct{})
	}
	for i := range ids {
		m.outputs[ids[i]] = struct{}{}
	}
}

// ClearOutputs clears the "outputs" edge to the TaskStepOutput entity.
func (m *TaskStepMutation) ClearOutputs() {
	m.clearedoutputs = true
}

// OutputsCleared reports if the "outputs" edge to the TaskStepOutput entity was cleared.
func (m *TaskStepMutation) OutputsCleared() bool {
	return m.clearedoutputs
}

// RemoveOutputIDs removes the "outputs" edge to the TaskStepOutput entity by IDs.
func (m *TaskStepMutation) RemoveOutputIDs(ids ...uint64) {
	if m.removedoutputs == nil {
		m.removedoutputs = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.outputs, ids[i])
		m.removedoutputs[ids[i]] = struct{}{}
	}
}

// RemovedOutputs returns the removed IDs of the "outputs" edge to the TaskStepOutput entity.
func (m *TaskStepMutation) RemovedOutputsIDs() (ids []uint64) {
	for id := range m.removedoutputs {
		ids = append(ids, id)
	}
	return
}

// OutputsIDs returns the "outputs" edge IDs in the mutation.
func (m *TaskStepMutation) OutputsIDs() (ids []uint64) {
	for id := range m.outputs {
		ids = append(ids, id)
	}
	return
}

// ResetOutputs resets all changes to the "outputs" edge.
func (m *TaskStepMutation) ResetOutputs() {
	m.outputs = nil
	m.clearedoutputs = false
	m.removedoutputs = nil
}

// Where appends a list predicates to the TaskStepMutation builder.
func (m *TaskStepMutation) Where(ps ...predicate.TaskStep) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskStepMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskStepMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TaskStep, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskStepMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskStepMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TaskStep).
func (m *TaskStepMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskStepMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, taskstep.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, taskstep.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, taskstep.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, taskstep.FieldUpdatedBy)
	}
	if m.disabled != nil {
		fields = append(fields, taskstep.FieldDisabled)
	}
	if m.message != nil {
		fields = append(fields, taskstep.FieldMessage)
	}
	if m.state != nil {
		fields = append(fields, taskstep.FieldState)
	}
	if m.previous_state != nil {
		fields = append(fields, taskstep.FieldPreviousState)
	}
	if m.start_time != nil {
		fields = append(fields, taskstep.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, taskstep.FieldEndTime)
	}
	if m.task != nil {
		fields = append(fields, taskstep.FieldTaskID)
	}
	if m.step != nil {
		fields = append(fields, taskstep.FieldStepID)
	}
	if m.seq_no != nil {
		fields = append(fields, taskstep.FieldSeqNo)
	}
	if m.code != nil {
		fields = append(fields, taskstep.FieldCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskStepMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case taskstep.FieldCreatedAt:
		return m.CreatedAt()
	case taskstep.FieldUpdatedAt:
		return m.UpdatedAt()
	case taskstep.FieldCreatedBy:
		return m.CreatedBy()
	case taskstep.FieldUpdatedBy:
		return m.UpdatedBy()
	case taskstep.FieldDisabled:
		return m.Disabled()
	case taskstep.FieldMessage:
		return m.Message()
	case taskstep.FieldState:
		return m.State()
	case taskstep.FieldPreviousState:
		return m.PreviousState()
	case taskstep.FieldStartTime:
		return m.StartTime()
	case taskstep.FieldEndTime:
		return m.EndTime()
	case taskstep.FieldTaskID:
		return m.TaskID()
	case taskstep.FieldStepID:
		return m.StepID()
	case taskstep.FieldSeqNo:
		return m.SeqNo()
	case taskstep.FieldCode:
		return m.Code()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskStepMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case taskstep.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case taskstep.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case taskstep.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case taskstep.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case taskstep.FieldDisabled:
		return m.OldDisabled(ctx)
	case taskstep.FieldMessage:
		return m.OldMessage(ctx)
	case taskstep.FieldState:
		return m.OldState(ctx)
	case taskstep.FieldPreviousState:
		return m.OldPreviousState(ctx)
	case taskstep.FieldStartTime:
		return m.OldStartTime(ctx)
	case taskstep.FieldEndTime:
		return m.OldEndTime(ctx)
	case taskstep.FieldTaskID:
		return m.OldTaskID(ctx)
	case taskstep.FieldStepID:
		return m.OldStepID(ctx)
	case taskstep.FieldSeqNo:
		return m.OldSeqNo(ctx)
	case taskstep.FieldCode:
		return m.OldCode(ctx)
	}
	return nil, fmt.Errorf("unknown TaskStep field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskStepMutation) SetField(name string, value ent.Value) error {
	switch name {
	case taskstep.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case taskstep.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case taskstep.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case taskstep.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case taskstep.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case taskstep.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case taskstep.FieldState:
		v, ok := value.(taskstep.State)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case taskstep.FieldPreviousState:
		v, ok := value.(taskstep.PreviousState)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreviousState(v)
		return nil
	case taskstep.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case taskstep.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case taskstep.FieldTaskID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case taskstep.FieldStepID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStepID(v)
		return nil
	case taskstep.FieldSeqNo:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeqNo(v)
		return nil
	case taskstep.FieldCode:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	}
	return fmt.Errorf("unknown TaskStep field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskStepMutation) AddedFields() []string {
	var fields []string
	if m.addseq_no != nil {
		fields = append(fields, taskstep.FieldSeqNo)
	}
	if m.addcode != nil {
		fields = append(fields, taskstep.FieldCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskStepMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case taskstep.FieldSeqNo:
		return m.AddedSeqNo()
	case taskstep.FieldCode:
		return m.AddedCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskStepMutation) AddField(name string, value ent.Value) error {
	switch name {
	case taskstep.FieldSeqNo:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSeqNo(v)
		return nil
	case taskstep.FieldCode:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCode(v)
		return nil
	}
	return fmt.Errorf("unknown TaskStep numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskStepMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(taskstep.FieldCreatedAt) {
		fields = append(fields, taskstep.FieldCreatedAt)
	}
	if m.FieldCleared(taskstep.FieldUpdatedAt) {
		fields = append(fields, taskstep.FieldUpdatedAt)
	}
	if m.FieldCleared(taskstep.FieldCreatedBy) {
		fields = append(fields, taskstep.FieldCreatedBy)
	}
	if m.FieldCleared(taskstep.FieldUpdatedBy) {
		fields = append(fields, taskstep.FieldUpdatedBy)
	}
	if m.FieldCleared(taskstep.FieldDisabled) {
		fields = append(fields, taskstep.FieldDisabled)
	}
	if m.FieldCleared(taskstep.FieldMessage) {
		fields = append(fields, taskstep.FieldMessage)
	}
	if m.FieldCleared(taskstep.FieldState) {
		fields = append(fields, taskstep.FieldState)
	}
	if m.FieldCleared(taskstep.FieldPreviousState) {
		fields = append(fields, taskstep.FieldPreviousState)
	}
	if m.FieldCleared(taskstep.FieldStartTime) {
		fields = append(fields, taskstep.FieldStartTime)
	}
	if m.FieldCleared(taskstep.FieldEndTime) {
		fields = append(fields, taskstep.FieldEndTime)
	}
	if m.FieldCleared(taskstep.FieldSeqNo) {
		fields = append(fields, taskstep.FieldSeqNo)
	}
	if m.FieldCleared(taskstep.FieldCode) {
		fields = append(fields, taskstep.FieldCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskStepMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskStepMutation) ClearField(name string) error {
	switch name {
	case taskstep.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case taskstep.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case taskstep.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case taskstep.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case taskstep.FieldDisabled:
		m.ClearDisabled()
		return nil
	case taskstep.FieldMessage:
		m.ClearMessage()
		return nil
	case taskstep.FieldState:
		m.ClearState()
		return nil
	case taskstep.FieldPreviousState:
		m.ClearPreviousState()
		return nil
	case taskstep.FieldStartTime:
		m.ClearStartTime()
		return nil
	case taskstep.FieldEndTime:
		m.ClearEndTime()
		return nil
	case taskstep.FieldSeqNo:
		m.ClearSeqNo()
		return nil
	case taskstep.FieldCode:
		m.ClearCode()
		return nil
	}
	return fmt.Errorf("unknown TaskStep nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskStepMutation) ResetField(name string) error {
	switch name {
	case taskstep.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case taskstep.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case taskstep.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case taskstep.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case taskstep.FieldDisabled:
		m.ResetDisabled()
		return nil
	case taskstep.FieldMessage:
		m.ResetMessage()
		return nil
	case taskstep.FieldState:
		m.ResetState()
		return nil
	case taskstep.FieldPreviousState:
		m.ResetPreviousState()
		return nil
	case taskstep.FieldStartTime:
		m.ResetStartTime()
		return nil
	case taskstep.FieldEndTime:
		m.ResetEndTime()
		return nil
	case taskstep.FieldTaskID:
		m.ResetTaskID()
		return nil
	case taskstep.FieldStepID:
		m.ResetStepID()
		return nil
	case taskstep.FieldSeqNo:
		m.ResetSeqNo()
		return nil
	case taskstep.FieldCode:
		m.ResetCode()
		return nil
	}
	return fmt.Errorf("unknown TaskStep field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskStepMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.task != nil {
		edges = append(edges, taskstep.EdgeTask)
	}
	if m.step != nil {
		edges = append(edges, taskstep.EdgeStep)
	}
	if m.outputs != nil {
		edges = append(edges, taskstep.EdgeOutputs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskStepMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case taskstep.EdgeTask:
		if id := m.task; id != nil {
			return []ent.Value{*id}
		}
	case taskstep.EdgeStep:
		if id := m.step; id != nil {
			return []ent.Value{*id}
		}
	case taskstep.EdgeOutputs:
		ids := make([]ent.Value, 0, len(m.outputs))
		for id := range m.outputs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskStepMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedoutputs != nil {
		edges = append(edges, taskstep.EdgeOutputs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskStepMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case taskstep.EdgeOutputs:
		ids := make([]ent.Value, 0, len(m.removedoutputs))
		for id := range m.removedoutputs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskStepMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtask {
		edges = append(edges, taskstep.EdgeTask)
	}
	if m.clearedstep {
		edges = append(edges, taskstep.EdgeStep)
	}
	if m.clearedoutputs {
		edges = append(edges, taskstep.EdgeOutputs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskStepMutation) EdgeCleared(name string) bool {
	switch name {
	case taskstep.EdgeTask:
		return m.clearedtask
	case taskstep.EdgeStep:
		return m.clearedstep
	case taskstep.EdgeOutputs:
		return m.clearedoutputs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskStepMutation) ClearEdge(name string) error {
	switch name {
	case taskstep.EdgeTask:
		m.ClearTask()
		return nil
	case taskstep.EdgeStep:
		m.ClearStep()
		return nil
	}
	return fmt.Errorf("unknown TaskStep unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskStepMutation) ResetEdge(name string) error {
	switch name {
	case taskstep.EdgeTask:
		m.ResetTask()
		return nil
	case taskstep.EdgeStep:
		m.ResetStep()
		return nil
	case taskstep.EdgeOutputs:
		m.ResetOutputs()
		return nil
	}
	return fmt.Errorf("unknown TaskStep edge %s", name)
}

// TaskStepOutputMutation represents an operation that mutates the TaskStepOutput nodes in the graph.
type TaskStepOutputMutation struct {
	config
	op               Op
	typ              string
	id               *uint64
	created_at       *time.Time
	updated_at       *time.Time
	created_by       *string
	updated_by       *string
	timestamp        *int64
	addtimestamp     *int64
	content          *string
	clearedFields    map[string]struct{}
	task_step        *uint64
	clearedtask_step bool
	done             bool
	oldValue         func(context.Context) (*TaskStepOutput, error)
	predicates       []predicate.TaskStepOutput
}

var _ ent.Mutation = (*TaskStepOutputMutation)(nil)

// taskstepoutputOption allows management of the mutation configuration using functional options.
type taskstepoutputOption func(*TaskStepOutputMutation)

// newTaskStepOutputMutation creates new mutation for the TaskStepOutput entity.
func newTaskStepOutputMutation(c config, op Op, opts ...taskstepoutputOption) *TaskStepOutputMutation {
	m := &TaskStepOutputMutation{
		config:        c,
		op:            op,
		typ:           TypeTaskStepOutput,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskStepOutputID sets the ID field of the mutation.
func withTaskStepOutputID(id uint64) taskstepoutputOption {
	return func(m *TaskStepOutputMutation) {
		var (
			err   error
			once  sync.Once
			value *TaskStepOutput
		)
		m.oldValue = func(ctx context.Context) (*TaskStepOutput, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TaskStepOutput.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTaskStepOutput sets the old TaskStepOutput of the mutation.
func withTaskStepOutput(node *TaskStepOutput) taskstepoutputOption {
	return func(m *TaskStepOutputMutation) {
		m.oldValue = func(context.Context) (*TaskStepOutput, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskStepOutputMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskStepOutputMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entv1: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TaskStepOutput entities.
func (m *TaskStepOutputMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskStepOutputMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskStepOutputMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TaskStepOutput.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskStepOutputMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskStepOutputMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TaskStepOutput entity.
// If the TaskStepOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskStepOutputMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TaskStepOutputMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[taskstepoutput.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TaskStepOutputMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[taskstepoutput.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskStepOutputMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, taskstepoutput.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskStepOutputMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskStepOutputMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TaskStepOutput entity.
// If the TaskStepOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskStepOutputMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TaskStepOutputMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[taskstepoutput.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TaskStepOutputMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[taskstepoutput.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskStepOutputMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, taskstepoutput.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *TaskStepOutputMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TaskStepOutputMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the TaskStepOutput entity.
// If the TaskStepOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskStepOutputMutation) OldCreatedBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *TaskStepOutputMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[taskstepoutput.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *TaskStepOutputMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[taskstepoutput.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TaskStepOutputMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, taskstepoutput.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TaskStepOutputMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TaskStepOutputMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the TaskStepOutput entity.
// If the TaskStepOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskStepOutputMutation) OldUpdatedBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *TaskStepOutputMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[taskstepoutput.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *TaskStepOutputMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[taskstepoutput.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TaskStepOutputMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, taskstepoutput.FieldUpdatedBy)
}

// SetExecID sets the "exec_id" field.
func (m *TaskStepOutputMutation) SetExecID(u uint64) {
	m.task_step = &u
}

// ExecID returns the value of the "exec_id" field in the mutation.
func (m *TaskStepOutputMutation) ExecID() (r uint64, exists bool) {
	v := m.task_step
	if v == nil {
		return
	}
	return *v, true
}

// OldExecID returns the old "exec_id" field's value of the TaskStepOutput entity.
// If the TaskStepOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskStepOutputMutation) OldExecID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecID: %w", err)
	}
	return oldValue.ExecID, nil
}

// ResetExecID resets all changes to the "exec_id" field.
func (m *TaskStepOutputMutation) ResetExecID() {
	m.task_step = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *TaskStepOutputMutation) SetTimestamp(i int64) {
	m.timestamp = &i
	m.addtimestamp = nil
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *TaskStepOutputMutation) Timestamp() (r int64, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the TaskStepOutput entity.
// If the TaskStepOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskStepOutputMutation) OldTimestamp(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// AddTimestamp adds i to the "timestamp" field.
func (m *TaskStepOutputMutation) AddTimestamp(i int64) {
	if m.addtimestamp != nil {
		*m.addtimestamp += i
	} else {
		m.addtimestamp = &i
	}
}

// AddedTimestamp returns the value that was added to the "timestamp" field in this mutation.
func (m *TaskStepOutputMutation) AddedTimestamp() (r int64, exists bool) {
	v := m.addtimestamp
	if v == nil {
		return
	}
	return *v, true
}

// ClearTimestamp clears the value of the "timestamp" field.
func (m *TaskStepOutputMutation) ClearTimestamp() {
	m.timestamp = nil
	m.addtimestamp = nil
	m.clearedFields[taskstepoutput.FieldTimestamp] = struct{}{}
}

// TimestampCleared returns if the "timestamp" field was cleared in this mutation.
func (m *TaskStepOutputMutation) TimestampCleared() bool {
	_, ok := m.clearedFields[taskstepoutput.FieldTimestamp]
	return ok
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *TaskStepOutputMutation) ResetTimestamp() {
	m.timestamp = nil
	m.addtimestamp = nil
	delete(m.clearedFields, taskstepoutput.FieldTimestamp)
}

// SetContent sets the "content" field.
func (m *TaskStepOutputMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *TaskStepOutputMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the TaskStepOutput entity.
// If the TaskStepOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskStepOutputMutation) OldContent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *TaskStepOutputMutation) ClearContent() {
	m.content = nil
	m.clearedFields[taskstepoutput.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *TaskStepOutputMutation) ContentCleared() bool {
	_, ok := m.clearedFields[taskstepoutput.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *TaskStepOutputMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, taskstepoutput.FieldContent)
}

// SetTaskStepID sets the "task_step" edge to the TaskStep entity by id.
func (m *TaskStepOutputMutation) SetTaskStepID(id uint64) {
	m.task_step = &id
}

// ClearTaskStep clears the "task_step" edge to the TaskStep entity.
func (m *TaskStepOutputMutation) ClearTaskStep() {
	m.clearedtask_step = true
	m.clearedFields[taskstepoutput.FieldExecID] = struct{}{}
}

// TaskStepCleared reports if the "task_step" edge to the TaskStep entity was cleared.
func (m *TaskStepOutputMutation) TaskStepCleared() bool {
	return m.clearedtask_step
}

// TaskStepID returns the "task_step" edge ID in the mutation.
func (m *TaskStepOutputMutation) TaskStepID() (id uint64, exists bool) {
	if m.task_step != nil {
		return *m.task_step, true
	}
	return
}

// TaskStepIDs returns the "task_step" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskStepID instead. It exists only for internal usage by the builders.
func (m *TaskStepOutputMutation) TaskStepIDs() (ids []uint64) {
	if id := m.task_step; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTaskStep resets all changes to the "task_step" edge.
func (m *TaskStepOutputMutation) ResetTaskStep() {
	m.task_step = nil
	m.clearedtask_step = false
}

// Where appends a list predicates to the TaskStepOutputMutation builder.
func (m *TaskStepOutputMutation) Where(ps ...predicate.TaskStepOutput) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskStepOutputMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskStepOutputMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TaskStepOutput, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskStepOutputMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskStepOutputMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TaskStepOutput).
func (m *TaskStepOutputMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskStepOutputMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, taskstepoutput.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, taskstepoutput.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, taskstepoutput.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, taskstepoutput.FieldUpdatedBy)
	}
	if m.task_step != nil {
		fields = append(fields, taskstepoutput.FieldExecID)
	}
	if m.timestamp != nil {
		fields = append(fields, taskstepoutput.FieldTimestamp)
	}
	if m.content != nil {
		fields = append(fields, taskstepoutput.FieldContent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskStepOutputMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case taskstepoutput.FieldCreatedAt:
		return m.CreatedAt()
	case taskstepoutput.FieldUpdatedAt:
		return m.UpdatedAt()
	case taskstepoutput.FieldCreatedBy:
		return m.CreatedBy()
	case taskstepoutput.FieldUpdatedBy:
		return m.UpdatedBy()
	case taskstepoutput.FieldExecID:
		return m.ExecID()
	case taskstepoutput.FieldTimestamp:
		return m.Timestamp()
	case taskstepoutput.FieldContent:
		return m.Content()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskStepOutputMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case taskstepoutput.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case taskstepoutput.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case taskstepoutput.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case taskstepoutput.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case taskstepoutput.FieldExecID:
		return m.OldExecID(ctx)
	case taskstepoutput.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case taskstepoutput.FieldContent:
		return m.OldContent(ctx)
	}
	return nil, fmt.Errorf("unknown TaskStepOutput field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskStepOutputMutation) SetField(name string, value ent.Value) error {
	switch name {
	case taskstepoutput.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case taskstepoutput.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case taskstepoutput.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case taskstepoutput.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case taskstepoutput.FieldExecID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecID(v)
		return nil
	case taskstepoutput.FieldTimestamp:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case taskstepoutput.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	}
	return fmt.Errorf("unknown TaskStepOutput field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskStepOutputMutation) AddedFields() []string {
	var fields []string
	if m.addtimestamp != nil {
		fields = append(fields, taskstepoutput.FieldTimestamp)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskStepOutputMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case taskstepoutput.FieldTimestamp:
		return m.AddedTimestamp()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskStepOutputMutation) AddField(name string, value ent.Value) error {
	switch name {
	case taskstepoutput.FieldTimestamp:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown TaskStepOutput numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskStepOutputMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(taskstepoutput.FieldCreatedAt) {
		fields = append(fields, taskstepoutput.FieldCreatedAt)
	}
	if m.FieldCleared(taskstepoutput.FieldUpdatedAt) {
		fields = append(fields, taskstepoutput.FieldUpdatedAt)
	}
	if m.FieldCleared(taskstepoutput.FieldCreatedBy) {
		fields = append(fields, taskstepoutput.FieldCreatedBy)
	}
	if m.FieldCleared(taskstepoutput.FieldUpdatedBy) {
		fields = append(fields, taskstepoutput.FieldUpdatedBy)
	}
	if m.FieldCleared(taskstepoutput.FieldTimestamp) {
		fields = append(fields, taskstepoutput.FieldTimestamp)
	}
	if m.FieldCleared(taskstepoutput.FieldContent) {
		fields = append(fields, taskstepoutput.FieldContent)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskStepOutputMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskStepOutputMutation) ClearField(name string) error {
	switch name {
	case taskstepoutput.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case taskstepoutput.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case taskstepoutput.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case taskstepoutput.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case taskstepoutput.FieldTimestamp:
		m.ClearTimestamp()
		return nil
	case taskstepoutput.FieldContent:
		m.ClearContent()
		return nil
	}
	return fmt.Errorf("unknown TaskStepOutput nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskStepOutputMutation) ResetField(name string) error {
	switch name {
	case taskstepoutput.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case taskstepoutput.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case taskstepoutput.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case taskstepoutput.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case taskstepoutput.FieldExecID:
		m.ResetExecID()
		return nil
	case taskstepoutput.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case taskstepoutput.FieldContent:
		m.ResetContent()
		return nil
	}
	return fmt.Errorf("unknown TaskStepOutput field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskStepOutputMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.task_step != nil {
		edges = append(edges, taskstepoutput.EdgeTaskStep)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskStepOutputMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case taskstepoutput.EdgeTaskStep:
		if id := m.task_step; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskStepOutputMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskStepOutputMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskStepOutputMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtask_step {
		edges = append(edges, taskstepoutput.EdgeTaskStep)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskStepOutputMutation) EdgeCleared(name string) bool {
	switch name {
	case taskstepoutput.EdgeTaskStep:
		return m.clearedtask_step
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskStepOutputMutation) ClearEdge(name string) error {
	switch name {
	case taskstepoutput.EdgeTaskStep:
		m.ClearTaskStep()
		return nil
	}
	return fmt.Errorf("unknown TaskStepOutput unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskStepOutputMutation) ResetEdge(name string) error {
	switch name {
	case taskstepoutput.EdgeTaskStep:
		m.ResetTaskStep()
		return nil
	}
	return fmt.Errorf("unknown TaskStepOutput edge %s", name)
}
